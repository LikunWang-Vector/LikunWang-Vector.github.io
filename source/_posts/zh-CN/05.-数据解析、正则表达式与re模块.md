---
title: "05. 数据解析、正则表达式与re模块"
date: 2022-12-29
updated: 2022-12-29
categories:
  - Python爬虫入门、进阶与实战
tags:
  - 爬虫
  - html
  - 正则表达式
  - python
  - pip
csdn_views: 401
csdn_likes: 2
csdn_comments: 1
csdn_favorites: 5
csdn_url: https://blog.csdn.net/m0_59180666/article/details/128479831
cover: /images/posts/05.-数据解析、正则表达式与re模块/9aed1a1d72ca.png
lang_pair:
  en: "05. Data Parsing, Regular Expressions and re Module"
---

> 本文迁移自CSDN博客
> 原文链接：[05. 数据解析、正则表达式与re模块](https://blog.csdn.net/m0_59180666/article/details/128479831)
> 📊 401 阅读 | 👍 2 点赞 | 💬 1 评论 | ⭐ 5 收藏

**目录**

数据解析概述

正则表达式

正则的概念：

正则表达式的优缺点：

正则的语法：

常用元字符：

量词：

贪婪匹配和惰性匹配

典型案例

re模块

re模块中常用的几个函数

总结

本节用到的全部代码（测试时请注释不看的部分，这样便于观察结果）

* * *

### 数据解析概述

在前几节中，我们基本掌握了抓取整个网页的基本技能，但是大多数情况下，我们并不需要整个网页的内容，譬如网页框架、广告、网页通知等。我们想要只抓取我们需要的目标数据，该怎么去处理呢？这就涉及到了数据解析！

我们将一共学习三种解析方式：

1\. re解析

2\. bs4解析

3\. xpath解析

这三种方式并不局限于单独使用，可以根据需求混合进行使用，我们写爬虫是完全以结果作为导向的，正所谓不管黑猫白猫，能抓得到耗子就是好猫嘛！只要能拿得到我们想要的数据，用什么方案并不重要。当我们能够掌握这些方法以后，再去考虑性能的问题。

* * *

### 正则表达式

说到数据解析，最先离不开的就是正则表达式了。

#### 正则的概念：

> 正则表达式（Regular Expression）是一种使用表达式对字符串进行匹配的语法规则。

说人话就是从一段话/代码中，通过一系列表达式提取出我们想要的部分。我们抓取到的网页源代码如大家所见，本质上就是一个超长字符串，那么想要从里面提取内容，用正则表达式再合适不过了！

#### 正则表达式的优缺点：

优点：速度快、效率高、准确性高

缺点：新手上手难度有点儿高

我们只要能够掌握正则编写的逻辑关系，写出一个提取页面内容的正则表达式其实并不复杂。

#### 正则的语法：

使用元字符进行排列组合用来匹配字符串。这里分享一个在线测试正则表达式的网站：

[在线测试正则表达式网站![](/images/posts/05.-数据解析、正则表达式与re模块/9aed1a1d72ca.png)https://tool.oschina.net/regex/](https://tool.oschina.net/regex/ "在线测试正则表达式网站")元字符：具有固定含义的特殊符号

#### 常用元字符：

``` . 匹配除换行符以外的任意字符 \w 匹配字母或数字或下划线 \s 匹配任意的空白符 \d 匹配数字 \n 匹配一个换行符 \t 匹配一个制表符 ^ 匹配字符串的开始 $ 匹配字符串的结尾 \W 匹配非字母或数字或下划线 \S 匹配非空白符 \D 匹配非数字 a|b 匹配字符a或b () 匹配括号内的表达式，也表示一个组 [...] 匹配字符组中的字符 [^...] 匹配除了字符组中字符的所有字符 ``` 

#### 量词：

控制前面的元字符出现的次数

``` * 重复零次或更多次 \+ 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 ``` 

#### 贪婪匹配和惰性匹配

``` .* 贪婪匹配 .*? 惰性匹配 ``` 

这两个要着重注意，因为我们写爬虫用的最多的就是这个惰性匹配。

#### 典型案例

``` 字符串:玩儿吃只因游戏，晚上一起上游戏。干嘛呢？打游戏啊 表达式:玩儿.*?游戏 结果为:玩儿吃只因游戏 表达式:玩儿.*游戏 结果为:玩儿吃只因游戏，晚上一起上游戏。干嘛呢？打游戏 字符串:<div>胡辣汤</div> 表达式:<.*> 结果为:<div>胡辣汤</div> 表达式:<.*?> 结果为:<div> </div> 字符串:<div>胡辣汤</div><div><span>饭团</span></div> 表达式:<div>.*</div> 结果为:<div>胡辣汤</div><div><span>饭团</span></div> 表达式:<div>.*?</div> 结果为:<div>胡辣汤</div> <div><span>饭团</span></div> ``` 

所以我们能发现这样一个规律：

.*?表示尽可能少的匹配

.*表示尽可能多的匹配

暂时先记住这个规律，后面写爬虫的时候会用到。

* * *

### re模块

接下来问题来了，正则表达式我会写了，怎么在Python程序里使用正则呢？

相信细心的小伙伴已经发现了正则表达式（**R** egular **E** xpression）的首字母就是re，也就是我们的re模块，所以我们只需要在Python程序中import re就可以用正则了。

#### re模块中常用的几个函数

1\. findall查找所有，返回一个list

``` # findall: 匹配字符串中所有的符合正则的内容 # lst=re.findall("\d+","我的电话号是:10086,我女朋友的电话是:10010") lst = re.findall(r"\d+", "我的电话号是:10086,我女朋友的电话是:10010") # 写一个r更好 print(lst) print('\n') ``` 

2\. search会进行匹配，但是如果匹配到了第一个结果，就会返回这个结果，如果匹配不上search返回的则是None

``` # search, 找到一个结果就返回, 返回的结果是match对象,拿数据需要.group() s = re.search(r"\d+", "我的电话号是:10086,我女朋友的电话是:10010") print(s) print(s.group()) print('\n') ``` 

3\. match只能从字符串的开头进行匹配

``` # match是从头开始匹配,返回的结果是match对象,拿数据需要.group() # t = re.match(r"\d+", "我的电话号是:10086,我女朋友的电话是:10010") #匹配不到，为空，group()时会报错 t = re.match(r"\d+", "10086,我女朋友的电话是:10010") print(t) print(t.group()) print('\n') ``` 

4\. finditer，和findall差不多，只不过这是返回的是迭代器（**重点** ）

``` # finditer: 匹配字符串中所有的内容[返回的是迭代器], 从迭代器中拿到内容需要.group() it = re.finditer(r"\d+", "我的电话号是:10086,我女朋友的电话是:10010") print(it) # 返回迭代器 print('\n') for i in it: print(i.group()) # 显示内容 print('\n') ``` 

5\. compile，可以将一个长长的正则进行预加载，方便后面的使用

``` # 预加载正则表达式 obj = re.compile(r"\d+") ret = obj.finditer("我的电话号是:10086,我女朋友的电话是:10010") print(ret) # 返回迭代器 print('\n') for j in ret: print(j.group()) # 显示内容 print('\n') ret = obj.findall("全体mood光向5看7all，看5看5，5宣布个42，54个洒哔") print(ret) print('\n') ``` 

6\. 正则中的内容如何单独提取？

单独获取到正则中的具体内容可以给分组起名字

``` s = """ <div class='qilin'><span id='1'>郭麒麟</span></div> <div class='iron'><span id='2'>宋铁</span></div> <div class='sucker'><span id='3'>大聪明</span></div> <div class='thinker'><span id='4'>范思哲</span></div> <div class='balabala'><span id='5'>胡说八道</span></div> """ obj = re.compile(r"<div class='.*?'><span id='\d+'>.*?</span></div>", re.S) # re.S:让.能匹配换行符 # 打印出来还比较繁琐 result = obj.finditer(s) for i in result: print(i.group()) print('\n') # (?P<分组名字>正则) 可以单独从正则匹配的内容中进一步提取内容 obj = re.compile(r"<div class='(?P<classes>.*?)'><span id='(?P<id>\d+)'>(?P<showname>.*?)</span></div>", re.S) # re.S:让.能匹配换行符 # 打印出来还比较繁琐 result = obj.finditer(s) for i in result: print(i.group("classes")) print(i.group("showname")) print(i.group("id")) print('\n') ``` 

这里能够看到我们可以通过使用分组，来对正则匹配到的内容进行进一步的筛选，使得结果更加清晰易读，也更具有价值。

* * *

### 总结

本节我们学习了数据解析非常重要的一个方法：正则表达式。还学习了正则表达式在Python中的应用：re模块。并通过多方面的例子练习了正则表达式的使用。

希望大家可以和我继续一起努力，一起增强个人能力~

（可以利用业余时间再多了解一些计算机网络知识和HTML、前端等知识，便于我们今后的学习）

关于HTML的学习大家可以参考我的另一个专栏[HTML入门、进阶与实战](https://blog.csdn.net/m0_59180666/category_12132070.html?spm=1001.2014.3001.5482 "HTML入门、进阶与实战")

* * *

### 本节用到的全部代码（测试时请注释不看的部分，这样便于观察结果）

``` import re # findall: 匹配字符串中所有的符合正则的内容 # lst=re.findall("\d+","我的电话号是:10086,我女朋友的电话是:10010") lst = re.findall(r"\d+", "我的电话号是:10086,我女朋友的电话是:10010") # 写一个r更好 print(lst) print('\n') # finditer: 匹配字符串中所有的内容[返回的是迭代器], 从迭代器中拿到内容需要.group() it = re.finditer(r"\d+", "我的电话号是:10086,我女朋友的电话是:10010") print(it) # 返回迭代器 print('\n') for i in it: print(i.group()) # 显示内容 print('\n') # search, 找到一个结果就返回, 返回的结果是match对象,拿数据需要.group() s = re.search(r"\d+", "我的电话号是:10086,我女朋友的电话是:10010") print(s) print(s.group()) print('\n') # match是从头开始匹配,返回的结果是match对象,拿数据需要.group() # t = re.match(r"\d+", "我的电话号是:10086,我女朋友的电话是:10010") #匹配不到，为空，group()时会报错 t = re.match(r"\d+", "10086,我女朋友的电话是:10010") print(t) print(t.group()) print('\n') # 预加载正则表达式 obj = re.compile(r"\d+") ret = obj.finditer("我的电话号是:10086,我女朋友的电话是:10010") print(ret) # 返回迭代器 print('\n') for j in ret: print(j.group()) # 显示内容 print('\n') ret = obj.findall("全体mood光向5看7all，看5看5，5宣布个42，54个洒哔") print(ret) print('\n') s = """ <div class='qilin'><span id='1'>郭麒麟</span></div> <div class='iron'><span id='2'>宋铁</span></div> <div class='sucker'><span id='3'>大聪明</span></div> <div class='thinker'><span id='4'>范思哲</span></div> <div class='balabala'><span id='5'>胡说八道</span></div> """ obj = re.compile(r"<div class='.*?'><span id='\d+'>.*?</span></div>", re.S) # re.S:让.能匹配换行符 # 打印出来还比较繁琐 result = obj.finditer(s) for i in result: print(i.group()) print('\n') # (?P<分组名字>正则) 可以单独从正则匹配的内容中进一步提取内容 obj = re.compile(r"<div class='(?P<classes>.*?)'><span id='(?P<id>\d+)'>(?P<showname>.*?)</span></div>", re.S) # re.S:让.能匹配换行符 # 打印出来还比较繁琐 result = obj.finditer(s) for i in result: print(i.group("classes")) print(i.group("showname")) print(i.group("id")) print('\n') ``` 
