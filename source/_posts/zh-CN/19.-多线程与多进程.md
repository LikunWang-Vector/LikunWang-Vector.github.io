---
title: "19. 多线程与多进程"
date: 2023-01-05
updated: 2023-01-05
categories:
  - Python爬虫入门、进阶与实战
tags:
  - python
  - 开发语言
  - 爬虫
  - 数据分析
  - 网络爬虫
csdn_views: 184
csdn_likes: 2
csdn_comments: 1
csdn_favorites: 4
csdn_url: https://blog.csdn.net/m0_59180666/article/details/128562553
cover: /images/posts/19.-多线程与多进程/ee87aaef5a99.png
lang_pair:
  en: "19. Multithreading and Multiprocessing"
---

> 本文迁移自CSDN博客
> 原文链接：[19. 多线程与多进程](https://blog.csdn.net/m0_59180666/article/details/128562553)
> 📊 184 阅读 | 👍 2 点赞 | 💬 1 评论 | ⭐ 4 收藏

**目录**

前言

单线程与多线程

首先看一个单线程例子

执行结果：

再来一个多线程的例子，调用Thread类：

看一下执行结果：

​编辑

也可以写一个子类来继承线程的属性：

看一下执行结果：

看一下执行结果：

多进程

我们还是导包，写一个实例：

看一下执行结果：

总结​​​​​​​

* * *

### 前言

首先介绍基本概念 

![](/images/posts/19.-多线程与多进程/ee87aaef5a99.png)

进程是资源单位，而线程是执行单位，一个进程至少包含一个线程。

启动每一个进程默认有一个主进程。

Python中的多线程是通过Thread类来实现的，多进程是通过Process类来实现的。

* * *

### 单线程与多线程

#### 首先看一个单线程例子

```python def func(): for i in range(1000): print("func", i) if __name__ == '__main__': func() for i in range(1000): print("main", i) ``` 

调用函数其实还是单线程，编译后执行会先执行func函数再执行main函数中的循环。

#### 执行结果：

![](/images/posts/19.-多线程与多进程/31e811215c92.png)

#### 再来一个多线程的例子，调用Thread类：

```python # 多线程 from threading import Thread # 线程类 def func(): for i in range(1000): print("func", i) if __name__ == '__main__': t = Thread(target=func) # 创建线程并给线程安排任务 t.start() # 多线程状态为可以开始工作状态, 具体的执行时间由CPU决定 for i in range(1000): print("main", i) ``` 

我们先用Thread类在主函数创建一个线程，再将它启动，设置为运行状态。至于执行时间等调度问题就交给CPU执行了。

#### 看一下执行结果：

#### ![](/images/posts/19.-多线程与多进程/4975d71dc218.png)

可以看到输出结果是func与main混杂的，说明两条线程是同时执行的，才会出现输出混在一起的情况。 

#### 也可以写一个子类来继承线程的属性：

```python # 多线程 from threading import Thread # 线程类 class MyThread(Thread): # def run(self): # 固定的 -> 当线程被执行的时候, 被执行的就是run() for i in range(1000): print("子线程", i) if __name__ == '__main__': t = MyThread() # t.run() # 方法的调用了. -> 单线程???? t.start() # 开启线程 for i in range(1000): print("主线程", i) ``` 

子类继承了Thread类的属性，它里面定义了run函数，当此子类被调用时，将运行run函数。

主类中同样是创建多线程子类对象，并开启线程。注意这里千万不要用run方法，否则变成了调用子类的方法，执行完毕后才会执行后面的代码，变成了类似刚刚举得单线程例子了。

#### 看一下执行结果：

![](/images/posts/19.-多线程与多进程/4d3cb813114b.png)

很明显也是主线程子线程同时进行的。

当然，我们也可以定义多个线程，效果也更复杂，但我们为了区分不同的子线程也可以进行传参命名来区分：

```python from threading import Thread def func(name): # ?? for i in range(1000): print(name, i) if __name__ == '__main__': t1 = Thread(target=func, args=("Alice",)) # 传递参数必须是元组 t1.start() t2 = Thread(target=func, args=("Bob",)) t2.start() ``` 

比如这个时候我们引入了两个子线程，向func函数传递参数name，输出结果就会带有子线程不同的特征值便于区分。注意：参数args传入的信息必须是元组形式。

#### 看一下执行结果：

![](/images/posts/19.-多线程与多进程/807da55bcaaa.png)

可以看到，我们的输出结果成功把两个子线程区分开来，便于我们查看结果。

* * *

### 多进程​​​​​​​

多进程在Python的写法和多线程是差不多的，但它背后的逻辑却有很大的不同。多进程对于CPU的开销比多线程要大得多，所以我们还是最常用多线程。

#### 我们还是导包，写一个实例：

```python from multiprocessing import Process def func(): for i in range(1000): print("子进程", i) if __name__ == '__main__': p = Process(target=func) p.start() for i in range(1000): print("主进程", i) ``` 

可以看到除了导包不同，调用的api不同，思路是一致的。

#### 

#### 看一下执行结果：

![](/images/posts/19.-多线程与多进程/51ea85d9a8c5.png)

可以看到也是并行的输出，效果类似。

* * *

### 总结

今天我们认识了线程、进程的概念，学习了如何在Python中调用多线程方法Thread类、多进程方法Process等，用几个简单的例子深入理解了上述概念。
