<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>电子科技大学操作系统期末复习笔记（三）：存储器管理 | Likun Wang | 王立坤</title><meta name="author" content="Likun Wang (王立坤)"><meta name="copyright" content="Likun Wang (王立坤)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（三）：存储器管理📊 3033 阅读 | 👍 14 点赞 | 💬 2 评论 | ⭐ 39 收藏  目录 前言 存储器管理 概述 存储管理 存储系统的结构 程序的诞生 空间分类 地址映射 程序链接的方式 静态链接 装入时动态链接 运行时动态链接 程序装入的方式 程序装入的两类三种方法 绝对装入 静态重定位 动态重定位√ 关键点">
<meta property="og:type" content="article">
<meta property="og:title" content="电子科技大学操作系统期末复习笔记（三）：存储器管理">
<meta property="og:url" content="https://your-domain.com/2023/02/14/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Likun Wang | 王立坤">
<meta property="og:description" content="本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（三）：存储器管理📊 3033 阅读 | 👍 14 点赞 | 💬 2 评论 | ⭐ 39 收藏  目录 前言 存储器管理 概述 存储管理 存储系统的结构 程序的诞生 空间分类 地址映射 程序链接的方式 静态链接 装入时动态链接 运行时动态链接 程序装入的方式 程序装入的两类三种方法 绝对装入 静态重定位 动态重定位√ 关键点">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://your-domain.com/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png">
<meta property="article:published_time" content="2023-02-14T15:00:00.000Z">
<meta property="article:modified_time" content="2023-02-14T15:00:00.000Z">
<meta property="article:author" content="Likun Wang (王立坤)">
<meta property="article:tag" content="存储器管理">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="虚拟存储">
<meta property="article:tag" content="页式段式段页式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://your-domain.com/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "电子科技大学操作系统期末复习笔记（三）：存储器管理",
  "url": "https://your-domain.com/2023/02/14/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/",
  "image": "https://your-domain.com/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png",
  "datePublished": "2023-02-14T15:00:00.000Z",
  "dateModified": "2023-02-14T15:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Likun Wang (王立坤)",
      "url": "https://github.com/veckun"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://your-domain.com/2023/02/14/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Likun Wang (王立坤)","link":"Link: ","source":"Source: Likun Wang | 王立坤","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '电子科技大学操作系统期末复习笔记（三）：存储器管理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/csdn-stats.css"><link rel="stylesheet" href="/css/lang-switch.css"><meta name="generator" content="Hexo 8.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">302</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">311</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">21</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/cv/"><i class="fa-fw fas fa-graduation-cap"></i><span> CV</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Likun Wang | 王立坤</span></a><a class="nav-page-title" href="/"><span class="site-name">电子科技大学操作系统期末复习笔记（三）：存储器管理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/cv/"><i class="fa-fw fas fa-graduation-cap"></i><span> CV</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">电子科技大学操作系统期末复习笔记（三）：存储器管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-14T15:00:00.000Z" title="Created 2023-02-15 00:00:00">2023-02-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-14T15:00:00.000Z" title="Updated 2023-02-15 00:00:00">2023-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">复习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">10.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>32mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:180,&quot;messagePrev&quot;:&quot;This article was last updated&quot;,&quot;messageNext&quot;:&quot;days ago. The content may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-02-15 00:00:00&quot;}" hidden></div><blockquote>
<p>本文迁移自CSDN博客<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59180666/article/details/129020067">电子科技大学操作系统期末复习笔记（三）：存储器管理</a><br>📊 3033 阅读 | 👍 14 点赞 | 💬 2 评论 | ⭐ 39 收藏</p>
</blockquote>
<p><strong>目录</strong></p>
<p>前言</p>
<p>存储器管理</p>
<p>概述</p>
<p>存储管理</p>
<p>存储系统的结构</p>
<p>程序的诞生</p>
<p>空间分类</p>
<p>地址映射</p>
<p>程序链接的方式</p>
<p>静态链接</p>
<p>装入时动态链接</p>
<p>运行时动态链接</p>
<p>程序装入的方式</p>
<p>程序装入的两类三种方法</p>
<p>绝对装入</p>
<p>静态重定位</p>
<p>动态重定位√</p>
<p>关键点</p>
<p>存储器管理：连续分配</p>
<p>单一连续分配</p>
<p>分区管理</p>
<p>固定分区分配</p>
<p>[放置算法（分配算法）]</p>
<p>动态分区分配</p>
<p>常用分区分配算法</p>
<p>[最先适配算法] </p>
<p>[循环最先适配算法] </p>
<p>[最佳适配算法] </p>
<p>[最坏适配算法]</p>
<p>[伙伴系统]</p>
<p>[碎片问题：紧凑&#x2F;动态重定位]</p>
<p>动态分区分配算法总结 </p>
<p>覆盖</p>
<p>基本概念</p>
<p>实例</p>
<p>缺点</p>
<p>交换&#x2F;对换</p>
<p>基本概念</p>
<p>交换粒度 </p>
<p>优缺点</p>
<p>交换与覆盖的比较</p>
<p>存储器管理：离散分配</p>
<p>页式存储管理</p>
<p>基本概念</p>
<p>[分页逻辑地址结构]</p>
<p>[基本页式存储管理]</p>
<p>[地址变换机构]</p>
<p>页式存储中的重定位</p>
<p>⭐重点计算方法：</p>
<p>具有快表的地址变换机构</p>
<p>[快表]</p>
<p>计算页表存储空间</p>
<p>两级和多级页表</p>
<p>[例题]</p>
<p>反置页表</p>
<p>页式存储小结</p>
<p>段式存储管理</p>
<p>基本概念</p>
<p>[评价]</p>
<p>段式地址变换</p>
<p>分配（类似动态分区）</p>
<p>与分页的比较</p>
<p>段页式存储管理</p>
<p>基本思想</p>
<p>地址映射</p>
<p>地址变换</p>
<p>地址变换实例</p>
<p>虚拟存储器 </p>
<p>基本概念</p>
<p>局部性原理</p>
<p>虚拟内存</p>
<p>虚拟页式</p>
<p>请求分页</p>
<p>内存分配、置换策略</p>
<p>缺页中断处理</p>
<p>系统颠簸&#x2F;抖动</p>
<p>工作集</p>
<p>页面替换&#x2F;置换算法 </p>
<p>最佳算法（OPT）</p>
<p>先进先出算法(First in First Out，FIFO)</p>
<p>最近最久未使用算法(LRU, Least Recently Used)</p>
<p>Clock算法</p>
<p>改进Clock算法</p>
<p>其他置换算法</p>
<p>练习题</p>
<p>​编辑</p>
<p>虚拟段式</p>
<p>请求分段</p>
<p>地址变换过程</p>
<p>虚拟段页式</p>
<p>分段的共享与保护 </p>
<p>总结</p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进程与并发控制已更新，传送门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59180666/article/details/128996730?spm=1001.2014.3001.5501" title="电子科技大学操作系统期末复习笔记（二）：进程与并发控制">电子科技大学操作系统期末复习笔记（二）：进程与并发控制</a></p>
<p>本复习笔记基于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6&spm=1001.2101.3001.7020" title="电子科技大学">电子科技大学</a>计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：</p>
<blockquote>
<ul>
<li><strong>CM1</strong><strong>：</strong> 操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。</li>
<li><strong>CM2</strong><strong>：</strong> 进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。</li>
<li><strong>CM3</strong><strong>：</strong> 内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。</li>
<li><strong>CM4</strong><strong>：</strong> 设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。</li>
<li><strong>CM5</strong><strong>：</strong> 文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。</li>
</ul>
</blockquote>
<p>本节要点在CM3，大致内容如下：</p>
<blockquote>
<p>第三章 存储器管理（14 学时，多媒体课件结合板书面授）CM3 </p>
<p>1、主要内容 </p>
<p>操作系统存储管理的需求分析；现代计算机系统的多级存储体系；存储划分技术；分区、动 </p>
<p>态分区分配算法；伙伴系统；分页&#x2F;分段存储管理；段页式存储管理技术。对换技术。虚拟存储器的基本概念，请求分页存储管理，请求分段存储管理，虚拟存储的软件策略：驻留集管理、页面获取、页面放置、页面置换算法、负载控制。 </p>
<p>2、应达到的要求 </p>
<p>记忆：多级存储体系结构、程序的装入和链接。 </p>
<p>理解：存储器管理相关技术、虚拟存储器的基本概念。 </p>
<p>应用：重定位与地址转换、分区存储管理、动态分区分配算法、交换技术、分页存储管理、 </p>
<p>各种页面置换算法、分段存储管理。 </p>
<p>分析：段页式存储管理、虚拟存储管理技术。</p>
</blockquote>
<p>本节涉及到4个PPT，分四个大块叙述。</p>
<hr>
<h2 id="存储器管理"><a href="#存储器管理" class="headerlink" title="存储器管理"></a>存储器管理</h2><hr>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h4><blockquote>
<p>定义</p>
<ul>
<li>主要是指对内存储器的管理</li>
<li>在多道程序环境之中，多个作业需共享内存资源，内存紧张的问题依然突出</li>
<li>存储管理是操作系统的重要组成部分，能否合理有效地利用内存在很大程度上影响着整个计算机的性能。</li>
</ul>
</blockquote>
<blockquote>
<p>主要目的</p>
<ul>
<li>提高资源的利用率，尽量满足多个用户对内存的要求；</li>
<li>方便用户使用内存，不必考虑作业具体放在哪块区域。</li>
</ul>
</blockquote>
<blockquote>
<p>应实现的主要功能</p>
<ul>
<li>分配和回收</li>
<li>共享</li>
<li>保护</li>
<li>扩充</li>
</ul>
</blockquote>
<h4 id="存储系统的结构"><a href="#存储系统的结构" class="headerlink" title="存储系统的结构"></a>存储系统的结构</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png"></p>
<h4 id="程序的诞生"><a href="#程序的诞生" class="headerlink" title="程序的诞生"></a>程序的诞生</h4><blockquote>
<p><strong>从源代码 → 可以在内存中运行的程序</strong></p>
<ul>
<li>编译 <ul>
<li>由编译程序（Compiler）将用户源代码编译成若个目标模块</li>
</ul>
</li>
<li>链接 <ul>
<li>由链接程序（Linker）将目标模块，以及所需要的库函数链接在一起，形成一个完整的装入模块</li>
</ul>
</li>
<li>装入 <ul>
<li>由装入程序（Loader）将装入模块装入内存。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/6db00983fe1a.png"></p>
<p>C语言的过程：预处理、编译、汇编、链接、加载</p>
</blockquote>
<h4 id="空间分类"><a href="#空间分类" class="headerlink" title="空间分类"></a>空间分类</h4><blockquote>
<p><strong>名空间：代码里的变量名（个人理解）</strong></p>
<ul>
<li>用汇编语言或高级语言编写程序时，用符号名来访问某一单元。</li>
<li>程序中由符号名组成的程序空间称为符号名空间，简称名空间。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>逻辑空间：汇编时分配的地址（个人理解）</strong></p>
<ul>
<li>源程序经过编译形成目标程序，每个目标程序都以0为基址顺序进行编址，原来用符号名访问的单元用具体的数据——单元号取代。</li>
<li>这样生成的目标程序占据一定的地址空间，称为逻辑地址空间，简称逻辑空间。</li>
<li>在逻辑空间中每条指令的地址和指令中要访问的操作数地址统称为逻辑地址。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>内存空间（物理空间）：加载入内存运行时的实际地址（个人理解）</strong></p>
<ul>
<li>内存由若干存储单元组成，每个存储单元有一个编号，这种编号可惟一标识一个存储单元，称为内存地址（或物理地址）。</li>
<li>内存地址的集合称为内存地址空间（或物理地址空间），简称内存空间（或物理空间）。</li>
<li>内存空间编号示例： <ul>
<li>一维线性空间，编址顺序为0，1，2，3，…… n-1，n的大小由实际组成存储器的存储单元个数决定。 比如，64K内存的空间编号为0，1，2，3，……65535。</li>
<li>（64K&#x3D;2^6*2^10&#x3D;2^16；空间地址为[0, 2^16-1]&#x3D;[0, 65535]）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>空间的关系</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/e4ac6a8b3255.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/acecd9d97e5f.png"></p>
</blockquote>
<h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><blockquote>
<ul>
<li>将逻辑地址转换为运行时机器直接寻址的物理地址。 <ul>
<li>当程序装入内存时，操作系统要为该程序分配具体的内存空间。</li>
<li>由于程序的逻辑地址与内存物理地址未必一致，CPU执行指令按物理地址进行的，要进行地址转换。</li>
<li>重定位(relocation)</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/70386d0be846.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/61db95729934.png"></p>
</blockquote>
<hr>
<h3 id="程序链接的方式"><a href="#程序链接的方式" class="headerlink" title="程序链接的方式"></a>程序链接的方式</h3><blockquote>
<ul>
<li>源程序经过编译后，可得到一组目标模块，再利用链接程序将目标模块链接形成装入模块：模块拼接</li>
<li>根据链接时机不同，链接分为三种： <ul>
<li>静态链接(Static Linking)</li>
<li>动态链接(Dynamic Linking) <ul>
<li>装入时动态链接(Load-time Dynamic Linking)</li>
<li>运行时动态链接(Runtime Dynamic Linking)</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><blockquote>
<ul>
<li>在(编译)链接阶段(程序运行之前)，将各目标模块及它们所需的库函数，链接成一个完整的装入模块，以后不再拆开。 <ul>
<li>相对地址的修改</li>
<li>变换外部调用符号</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/e99c58e97d6a.png"></p>
<p>个人理解：提前（静态）装入不需要额外的算力，装入后程序运行稳定</p>
</blockquote>
<h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><blockquote>
<ul>
<li>目标模块在装入内存时，采用边装入边链接的链接方式，装入后不再链接。 <ul>
<li>各目标模块分开存放，便于修改和更新。</li>
<li>便于目标模块的共享 <ul>
<li>静态链接：每个装入模块都含有其目标模块的拷贝，无法实现对目标模块的共享。</li>
<li>装入时动态链接：OS可将一个目标模块链接到多个装入模块上，实现多个应用程序对该模块的共享。</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>个人理解：装入再装可以同时给多个装，达到共享、便于修改的目的</p>
</blockquote>
<h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><blockquote>
<ul>
<li>在程序执行中需要该目标模块时，由OS找到该模块，将其装入内存，并把它链接到调用者模块上。</li>
<li>执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。 <ul>
<li>加快程序的装入</li>
<li>节省内存空间</li>
<li>共享</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>个人理解：运行再装可以灵活选自己需要的装入，节约内存，加快运行速度，还能共享模块</p>
</blockquote>
<hr>
<h3 id="程序装入的方式"><a href="#程序装入的方式" class="headerlink" title="程序装入的方式"></a>程序装入的方式</h3><blockquote>
<p>地址重定位：模块载入位置（可能伴随链接）</p>
</blockquote>
<h4 id="程序装入的两类三种方法"><a href="#程序装入的两类三种方法" class="headerlink" title="程序装入的两类三种方法"></a>程序装入的两类三种方法</h4><blockquote>
<ul>
<li>绝对装入 <ul>
<li>编译时完成</li>
</ul>
</li>
<li>可重定位装入 <ul>
<li>加载时执行，静态地址重定位</li>
<li>运行时执行，动态地址重定位</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h4><blockquote>
<ul>
<li>固定地址重定位，编译时知道进程在内存中的驻留地址，生成绝对代码，即在可执行文件中记录内存地址，装入时直接定位在该内存地址。</li>
<li>程序地址空间和内存地址空间一一对应</li>
<li>如果开始地址发生变化，必须重新编译代码</li>
<li>优点：装入过程简单</li>
<li>缺点：不灵活，不适于多道程序系统</li>
</ul>
</blockquote>
<h4 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h4><blockquote>
<ul>
<li>目标程序装入内存时，由装入程序对目标程序中的指令和数据的地址进行修改，即把程序的逻辑地址都改成物理内存地址。</li>
<li>当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换。</li>
<li>优点 <ul>
<li>易实现，无需硬件支持</li>
</ul>
</li>
<li>缺点 <ul>
<li>程序重定位后就不能移动，因而不能重新分配内存，不利于内存的有效利用。</li>
<li>程序在存储空间中只能连续分配，不能分布在内存的不同区域。</li>
<li>难于共享</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="动态重定位√"><a href="#动态重定位√" class="headerlink" title="动态重定位√"></a>动态重定位√</h4><blockquote>
<ul>
<li>程序装入内存时，不修改逻辑地址，在访问物理内存之前，再实时地将逻辑地址转换成物理地址。</li>
<li>优点 <ul>
<li>程序不必连续存放在内存中，可分散存储，可移动；</li>
<li>便于共享；</li>
<li>有利于紧缩、碎片问题的解决。</li>
</ul>
</li>
<li>缺点 <ul>
<li>需要硬件支持，实现存储管理的算法比较复杂。</li>
<li>主流方式</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><blockquote>
<p>绝对装入和静态重定位</p>
<ul>
<li>符号解析 + 地址重定位：紧耦合</li>
</ul>
</blockquote>
<blockquote>
<p>动态重定位</p>
<ul>
<li>符号解析→地址重定位：松耦合</li>
<li>链接和装载动作的交织</li>
</ul>
</blockquote>
<hr>
<h2 id="存储器管理：连续分配"><a href="#存储器管理：连续分配" class="headerlink" title="存储器管理：连续分配"></a>存储器管理：连续分配</h2><blockquote>
<p>存储器管理分为三大方式：连续分配、离散分配、虚拟存储器。</p>
</blockquote>
<hr>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><blockquote>
<p>基本思想</p>
<ul>
<li>整个内存空间分成系统区和用户区，系统区给操作系统使用，用户区给用户使用。</li>
<li>用户区分配给一个进程</li>
</ul>
</blockquote>
<blockquote>
<p>适用场合</p>
<ul>
<li>最简单，适用于单用户、单任务OS</li>
</ul>
</blockquote>
<blockquote>
<p>优点</p>
<ul>
<li>易于管理</li>
</ul>
</blockquote>
<blockquote>
<p>缺点</p>
<ul>
<li>对内存空间需求少的程序，造成内存浪费；</li>
<li>程序全部装入，很少使用的程序部分也占用内存。</li>
</ul>
</blockquote>
<hr>
<h3 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h3><blockquote>
<p>基本原理</p>
<ul>
<li>把内存分为一些大小相等或不等的分区；</li>
<li>每个应用进程占用一个分区，操作系统占用一个分区。</li>
</ul>
</blockquote>
<blockquote>
<p>特点</p>
<ul>
<li>适用于多道程序系统和分时系统</li>
</ul>
</blockquote>
<blockquote>
<p>问题</p>
<ul>
<li>内部碎片：占用分区之内未被利用的空间</li>
<li>外部碎片：占用分区之间难以利用的空闲分区</li>
<li>难以进行内存分区的共享。</li>
</ul>
</blockquote>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><blockquote>
<ul>
<li>把内存分为大小相等或不等的分区(partition)</li>
<li>分区的划分一般由系统管理员或操作系统决定，一旦划定，在整个执行过程中不变</li>
<li>特点 <ul>
<li>适用于多道程序系统和分时系统</li>
<li>支持多个程序并发执行</li>
</ul>
</li>
<li>问题 <ul>
<li>难以进行内存分区的共享</li>
<li>碎片</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/84bfea15137b.png"> 等大小分区和不等大小分区 </p>
<h4 id="放置算法（分配算法）"><a href="#放置算法（分配算法）" class="headerlink" title="[放置算法（分配算法）]"></a>[放置算法（分配算法）]</h4><p>当一个进程装入或换入主存中时，如果存储器中有多个足够大的空闲分区，放置算法确定分配哪个自由块。</p>
<ul>
<li>等大小分区 <ul>
<li>只要有一个可用分区，进程就可以装入该分区</li>
<li>如果所有分区都被占满了，须换出一个进程</li>
<li>一个程序可能太大而不能放到一个分区中</li>
</ul>
</li>
<li>不等大小分区 <ul>
<li>方法1：每个分区一个调度队列，将每个进程指定到适应它的最小分区。 <ul>
<li>内部碎片最小</li>
<li>缺点：一段时间没有大尺寸程序到来，<strong>小程序排队，大空间闲置。</strong></li>
</ul>
</li>
<li>方法2：所有进程一个队列。 <ul>
<li>当需要把一个进程装入主存时，选择可以保存该进程的最小的可用分区。</li>
<li>如果所有分区都已被占据，须进行交换。</li>
</ul>
</li>
</ul>
</li>
<li>优点： <ul>
<li>比单一连续分配方法，内存利用率提高了</li>
<li>可以支持多道程序</li>
<li>实现简单</li>
</ul>
</li>
<li>缺点： <ul>
<li>分区的数目在系统生成时确定，限制了系统中活跃进程的数目</li>
<li>小作业的内部碎片可能比较大</li>
<li>作业须预先能够估计要占用的内存空间</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/8f6fb45dd6b5.png"></p>
</blockquote>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><blockquote>
<p>在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。</p>
<ul>
<li>优点 <ul>
<li>没有内部碎片</li>
</ul>
</li>
<li>缺点 <ul>
<li>外部碎片</li>
</ul>
</li>
<li>分区分配算法 <ul>
<li>寻找空闲分区，需大等于程序的要求。</li>
<li>若大于要求，则将该分区进行分割，分别标记为“占用”和 “空闲”。</li>
</ul>
</li>
<li>分区释放算法 <ul>
<li>将相邻的空闲分区合并成一个空闲分区。</li>
</ul>
</li>
<li>优点 <ul>
<li>实现了主存共享，有助于多道程序设计；</li>
<li>主存利用率比固定分区高；</li>
<li>实现存储保护的措施比较简单。</li>
</ul>
</li>
<li>缺点 <ul>
<li>外部碎片→ 主存利用率低；</li>
<li>一个作业执行前必须全部装入主存。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="常用分区分配算法"><a href="#常用分区分配算法" class="headerlink" title="常用分区分配算法"></a>常用分区分配算法</h4><blockquote>
<ul>
<li>最先适配算法 </li>
<li>循环最先适配算法 </li>
<li>最佳适配算法 </li>
<li>最坏适配算法</li>
</ul>
</blockquote>
<h4 id="最先适配算法"><a href="#最先适配算法" class="headerlink" title="[最先适配算法]"></a>[最先适配算法]</h4><blockquote>
<ul>
<li>算法思想 <ul>
<li>按分区地址排序，从头查找，找到符合要求的第一个分区。</li>
</ul>
</li>
<li>算法实质 <ul>
<li>尽可能利用存储区低地址空闲区，尽量在高地址部分保存较大空闲区，以便一旦有分配大空闲区要求时，容易得到满足。</li>
<li><strong>空闲区按地址顺序组织</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/9ed07571d190.png"></p>
<ul>
<li>优点 <ul>
<li>分配简单，合并相邻空闲区也比较容易</li>
</ul>
</li>
<li>缺点 <ul>
<li>查找总是从表首开始，前面空闲区被分割的很小时，满足分配要求的可能性较小，<strong>查找次数较多</strong> 。</li>
</ul>
</li>
<li>解决方法 <ul>
<li>对最先适配法稍加改进 → 循环最先适配法。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="循环最先适配算法"><a href="#循环最先适配算法" class="headerlink" title="[循环最先适配算法]"></a>[循环最先适配算法]</h4><blockquote>
<ul>
<li>算法思想 <ul>
<li>按分区先后次序，<strong>从上次分配的分区起 查找</strong>（到最后分区时再回到开头），找到符合要求的第一个分区</li>
</ul>
</li>
<li>特点 <ul>
<li>算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但<strong>较大的空闲分区不易保留。</strong></li>
<li><strong>空闲区按顺序组织</strong></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="最佳适配算法"><a href="#最佳适配算法" class="headerlink" title="[最佳适配算法]"></a>[最佳适配算法]</h4><blockquote>
<ul>
<li>算法思想 <ul>
<li>在所有大等于要求分配长度的空闲区中挑选一个最小的分区，即对该分区所要求分配的大小来说，是最合适的。</li>
</ul>
</li>
<li>算法实现 <ul>
<li><strong>空闲区从小到大顺序组织</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/5ad989fc6d80.png"></p>
<ul>
<li>优点 <ul>
<li>较大的空闲分区可以被保留</li>
</ul>
</li>
<li>缺点 <ul>
<li>空闲区按大小而不是按地址顺序排列，因此释放时，<strong>要在整个链表上搜索地址相邻的空闲区</strong> ，合并后，插入到合适的位置。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="最坏适配算法"><a href="#最坏适配算法" class="headerlink" title="[最坏适配算法]"></a>[最坏适配算法]</h4><blockquote>
<ul>
<li>算法思想 <ul>
<li>分区时取所有空闲区中最大的一块，必要时拆分形成2个块，一个选用，一个形成新空闲块。</li>
</ul>
</li>
<li>算法实现 <ul>
<li><strong>空闲区按由大到小排序</strong></li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/ba3f2ed62fec.png"></p>
<ul>
<li>优点 <ul>
<li>分配时，只需查找一次，就可成功，分配算法很快。</li>
</ul>
</li>
<li>缺点 <ul>
<li>最后剩余分区会越来越小，无法运行大程序</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="[伙伴系统]"></a>[伙伴系统]</h4><blockquote>
<ul>
<li>按照页面组织为块（2的k次幂个页面）</li>
<li>申请时对半拆分，直到能够容纳申请量，空闲的放入新队列</li>
<li>释放回收时合并：尺寸相同</li>
<li>速度快，但利用率不高</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/7eced39460a1.png"></p>
</blockquote>
<h4 id="碎片问题：紧凑-动态重定位"><a href="#碎片问题：紧凑-动态重定位" class="headerlink" title="[碎片问题：紧凑&#x2F;动态重定位]"></a>[碎片问题：紧凑&#x2F;动态重定位]</h4><blockquote>
<ul>
<li>碎片问题 <ul>
<li>经过一段时间分配、回收后，内存中存在很多很小的空闲块。</li>
<li>每一个都很小，不足以满足分配要求；</li>
<li>但其总和满足分配要求→存储资源浪费。</li>
</ul>
</li>
<li>解决方法 <ul>
<li>紧凑技术 <ul>
<li>在内存移动程序，将所有小的空闲区合并为大空闲区域</li>
<li>系统开销大</li>
</ul>
</li>
<li>离散分配方式</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/846a4708cf8d.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/8b6f5dcee2b6.png"></p>
</blockquote>
<h4 id="动态分区分配算法总结"><a href="#动态分区分配算法总结" class="headerlink" title="动态分区分配算法总结"></a>动态分区分配算法总结</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/d70bfe8b2ba1.png"></p>
<hr>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<ul>
<li>一个程序的几个代码段或数据段，按照时间先后占用公共的内存空间 <ul>
<li>将程序的必要部分代码和数据常驻内存；</li>
<li>可选部分在独立模块中，平时存放在外存中（覆盖文件），需要时才装入到内存；</li>
<li><strong>不存在调用关系的模块</strong> 不必同时装入到内存，可相互覆盖。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4></blockquote>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/e8316aed8f3f.png"></p>
<p>注：<strong>不存在调用关系的模块才可以相互覆盖！</strong></p>
<p>覆盖不需要OS提供特殊的支持，但程序员必须适当地设计和编写覆盖结构。</p>
</blockquote>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><blockquote>
<ul>
<li>编程时必须划分程序模块和确定程序模块之间的覆盖关系 → 增加编程复杂度。 </li>
<li>从外存装入覆盖文件，<strong>以时间换空间</strong> 。</li>
</ul>
</blockquote>
<hr>
<h3 id="交换-对换"><a href="#交换-对换" class="headerlink" title="交换&#x2F;对换"></a>交换&#x2F;对换</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>多个程序并发执行：</p>
<p>将暂时不能执行的程序换出到外存中，从而获得空闲内存空间来装入新程序；</p>
<p>或读入保存在外存中而目前到达就绪状态的进程到内存中。</p>
</blockquote>
<h4 id="交换粒度"><a href="#交换粒度" class="headerlink" title="交换粒度"></a>交换粒度</h4><blockquote>
<ul>
<li>整体交换 <ul>
<li>也称为进程交换，交换是以整个进程为单位</li>
</ul>
</li>
<li>部分交换 <ul>
<li>也称为页面交换、分段交换，是分页、分段交换的基础，目的是为了支持虚拟存储系统</li>
</ul>
</li>
<li>对换空间的管理 <ul>
<li>对换区一般采用连续分配</li>
<li>对换区比普通文件区侧重于对换速度</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><blockquote>
<ul>
<li>优点 <ul>
<li>增加并发程序数量，并给用户提供适当的响应时间；</li>
<li>编写程序时不影响程序结构</li>
</ul>
</li>
<li>缺点 <ul>
<li>换入和换出的控制增加处理机开销</li>
<li>时间换空间</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="交换与覆盖的比较"><a href="#交换与覆盖的比较" class="headerlink" title="交换与覆盖的比较"></a>交换与覆盖的比较</h4><blockquote>
<p>覆盖技术主要用在早期的操作系统中；</p>
<p>交换技术被广泛用于分时系统中，导致了虚存技术的出现；</p>
<p>覆盖发生在无调用关系程序段之间；</p>
<p>交换技术对程序段之间的逻辑关系无要求；</p>
<p>交换发生在进程或作业之间；</p>
<p>覆盖发生在同一进程或作业内。</p>
</blockquote>
<hr>
<h2 id="存储器管理：离散分配"><a href="#存储器管理：离散分配" class="headerlink" title="存储器管理：离散分配"></a>存储器管理：离散分配</h2><blockquote>
<p>连续分配一次性分配所有，不灵活</p>
<p>碎片问题：紧凑方式消耗系统开销</p>
<p>离散分配 分页、分段、段页</p>
</blockquote>
<hr>
<h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>用户空间划分：用户程序按逻辑页划分成大小相等的部分，称为页（虚页） 从0开始编制页号，页内地址相对于0编址。</p>
<p>逻辑空间划分由系统自动完成的，对用户透明。 一般页大小为2的整数次幂，因此，地址的高位部分为页号，低位部分为页内地址。</p>
<h4 id="分页逻辑地址结构"><a href="#分页逻辑地址结构" class="headerlink" title="[分页逻辑地址结构]"></a>[分页逻辑地址结构]</h4><p>页内地址：长度由页大小决定；</p>
<p>页号：除去页内地址所占的高位部分。</p>
<p>例：<strong>逻辑地址为32位，页大小为4KB</strong> ，则<strong>逻辑地址的低12位（2^12&#x3D;4KB），为页内地址w</strong> ，而<strong>高20位为页号p</strong> ，地址结构如下：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/981a17a380cc.png"></p>
<h4 id="基本页式存储管理"><a href="#基本页式存储管理" class="headerlink" title="[基本页式存储管理]"></a>[基本页式存储管理]</h4><ul>
<li>内存空间划分 <ul>
<li>按页的大小划分为<strong>大小相等的区域</strong> ，称为内存块（物理页面，页框、实页）→ frame</li>
<li><strong>从0开始</strong> 编号</li>
</ul>
</li>
<li>内存分配 <ul>
<li>以页为单位进行分配 <ul>
<li>内部碎片 → 最后一页的页内碎片</li>
<li>外部碎片？</li>
</ul>
</li>
<li><strong>逻辑上相邻的页，物理上不一定相邻；反之亦然</strong> 。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="[地址变换机构]"></a>[地址变换机构]</h4><ul>
<li>页表 page table <ul>
<li><strong>逻辑页号→物理块号的映射。</strong></li>
</ul>
</li>
<li>基本地址变换机构</li>
<li>每个进程拥有一个页表，其信息（如长度、始址）放在PCB中，执行时将其首地址装入页表寄存器。</li>
<li>页表在内存，属于进程的<strong>现场</strong> 信息(内核)。</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/aabf0c1062f2.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/3be2f13f07d2.png"><strong>⭐描述：将逻辑地址的页号取出和页表始址搭配找到页表中对应的块号，将块号取出和页内地址拼接成物理地址，如此循环，直到取出的逻辑地址页号大于页表长度，越界中断。</strong></p>
</blockquote>
<h4 id="页式存储中的重定位"><a href="#页式存储中的重定位" class="headerlink" title="页式存储中的重定位"></a>页式存储中的重定位</h4><p><strong>例题：</strong></p>
<p>一个系统，内存容量共256KB，页框大小为1KB，共256块，编号为0～255。 第0～4块为操作系统所使用； 现有2个用户作业，作业1和作业2，其逻辑地址空间分别占2KB和2.5KB； 进入系统后，按块的大小划分分别占2页和3页。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/982015f6472c.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/bc1e6ea6052e.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/6603bfc1dbf2.png"></p>
<blockquote>
<ul>
<li><h4 id="⭐重点计算方法："><a href="#⭐重点计算方法：" class="headerlink" title="⭐重点计算方法："></a>⭐重点计算方法：</h4></li>
<li><p>计算页号：逻辑地址&#x2F;页框大小；</p>
</li>
<li><p>页号 → 物理块号</p>
</li>
<li><p>页内偏移：逻辑地址%页框大小。 </p>
</li>
<li><p>物理地址：物理块号*页框大小+页内偏移</p>
</li>
</ul>
</blockquote>
<h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h4><blockquote>
<p>页表访存：二次 访页表 操作数据 </p>
</blockquote>
<h4 id="快表"><a href="#快表" class="headerlink" title="[快表]"></a>[快表]</h4><blockquote>
<ul>
<li>局部性：Locallity</li>
<li>高速缓冲存储器，存放当前作业的最常用的页号和与之相应的物理块号。</li>
<li>快表或联想存储器 <ul>
<li>Translation Lookaside Buffer （后备&#x2F;后援缓冲）</li>
<li>Associative Mapping（unordered）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/6bae90c9b775.png"></p>
<p>⭐<strong>描述：查找过的就放在快表里，拿到逻辑地址先找快表里，没有的话就输入快表再查页表，随后拼接页内地址即可</strong></p>
<hr>
<p><strong>练习：</strong></p>
<p>有一页式系统，其页表存放在主存中： 对主存的一次存取需要1.5μs，问实现一次页面访问的存取时间是多少? 如果系统有快表，平均命中率为85%，当页表项在快表中时，其查找时间忽略，问此时的平均存取时间是多少?</p>
<p>无快表主存存取访问时间：1.5*2&#x3D;3μs </p>
<p>增加快表后的存取访问时间： 0.85*1.5+(1-0.85)<em>2</em>1.5&#x3D;1.725μs</p>
</blockquote>
<h4 id="计算页表存储空间"><a href="#计算页表存储空间" class="headerlink" title="计算页表存储空间"></a>计算页表存储空间</h4><blockquote>
<p>页表也在内存，也需要按页存储</p>
<p>例子：</p>
<p>32位系统；页面大小：4K；页表项（页号记录）：4B；问：一个进程的页表需要多少存储空间？</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/b8975a052caa.png"></p>
<p>64位系统；页表项：8B；问：当页面大小为4K和1M时，一个进程的页表需要多少存储空间？</p>
<ul>
<li>4K：264&#x2F;4K * 8B&#x3D;255B&#x3D;32P</li>
<li>1M：264&#x2F;1M * 8B&#x3D;247B&#x3D;128T</li>
</ul>
</blockquote>
<h4 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h4><blockquote>
<p><strong>两级页表</strong></p>
<ul>
<li>逻辑地址结构： <ul>
<li>32位地址空间；页面大小4K；页表项4B</li>
<li>如何计算每一层的位数？每页表项数宽度</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/6b0b20ee6f19.png"></p>
<p><strong>二级页表查找过程</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/e5d41aaa7df8.png"></p>
<p>注意：页号是用来索引页表的，页表里存储的都是内存块号。 </p>
<p><strong>计算：</strong></p>
<p>64位系统；页面大小：4KB；页表项：8B；计算：2级页表存储空间；3级页表存储空间；至少设置几级页表才合理？（一级页表在一页内存储）</p>
<ul>
<li>2级页表: 每页页表项记录数量：4K&#x2F;8B&#x3D;2^9个 第2级页表项数量：2^64B&#x2F;4K&#x3D;2^52 第2级页表项所需页面数量：2^52&#x2F;2^9&#x3D;2^43个 第1级页表项数量：2^43 第1级页表项所需页面数量：2^43&#x2F;2^9&#x3D;2^34个 页表空间：(2^43+2^34) * 4K&#x3D;(2^13+2^4) * 4T&#x3D;32832T≈32.8P</li>
<li>3级页表: 每页页表项记录数量：4K&#x2F;8B&#x3D;2^9个 第3级页表项数量：2^64B&#x2F;4K&#x3D;2^52 第3级页表项所需页面数量：2^52&#x2F;2^9&#x3D;2^43个 第2级页表项数量：2^43 第2级页表项所需页面数量：2^43&#x2F;2^9&#x3D;2^34个 第1级页表项数量：2^34 第1级页表项所需页面数量：2^34&#x2F;2^9&#x3D;2^25个 页表空间：(2^43+2^34+2^25) * 4K&#x3D;(2^23+2^14+2^5) * 4G&#x3D;…</li>
<li>几级页表: 每页页表项数量：2^9 每9位切一刀 1次访存→7次访存 ⌈(64−12)&#x2F;9⌉⇒⌈(位数−页内偏移)&#x2F;每级别页号位数⌉⇒⌈log_2页面总数&#x2F;log_2页内表项数⌉</li>
</ul>
</blockquote>
<blockquote>
<p>多级页表令总空间增加，但通过按需装载，节省了内存空间。</p>
<p>评价：物理空间小，逻辑空间大。</p>
<p>页表大小∝逻辑空间大小 </p>
<p>物理内存变化速度&lt;&lt;逻辑空间</p>
</blockquote>
<h4 id="例题"><a href="#例题" class="headerlink" title="[例题]"></a>[例题]</h4><blockquote>
<p>某24位存储系统采用页式管理，页表分为两级，存储在主存中。每个页面1KB，每个页表项占4B，某进程的页表内容如下图所示（图中数字全部为10进制）。请计算逻辑地址526245（十进制）对应的物理地址。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/b8968fef51c3.png"></p>
<p>解答：</p>
<p>每个进程的总页面数为224B&#x2F;1KB&#x3D;214个，每个页面可存储页表项1KB&#x2F;4B&#x3D;256&#x3D;28个，存储二级页表所需要的页面数为：214&#x2F;28&#x3D;26个&lt;28个，则一级页表可以在一个页面内存储完成。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/5ac45f1c6ce3.png">526245对应的二进制表示（斜线表示上述逻辑切分）：10&#x2F;00 0000 01&#x2F;11 1010 0101</p>
<p>按照上述划分方法得到：一级页号为2，二级页号1，页内地址0x03A5。 </p>
<p>一级页表第2项查找到二级页表的物理块号：678</p>
<p>在678物理块的第1项找到物理块号889（0x0379），形成物理地址块号</p>
<p>与页内地址0x03A5拼接，形成完整的地址：</p>
<p>1101 1110 01&#x2F;11 1010 0101→0xDE7A5（十进制：911269） </p>
</blockquote>
<h4 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h4><blockquote>
<ul>
<li>物理块→逻辑块</li>
<li>也称为页寄存器（Page Register）</li>
<li>每个内存块关联： <ul>
<li>使用位(Residence bit): 本页是否被占用</li>
<li>使用者(Occupier): 占用此块的页号</li>
<li>进程号</li>
</ul>
</li>
<li>优点：存储开销小；页表大小与逻辑空间无关；全系统一张表</li>
<li>缺点：反向关联信息（页框号→页号），如何正向查询？</li>
</ul>
</blockquote>
<blockquote>
<p>哈希算法：</p>
<p>哈希运算：h(PID, 页号)→页框号</p>
<p>查询过程 计算h(p, i)，并作为索引访问反置页表；</p>
<p>获取反置页表项；</p>
<p>如果匹配(pid, 页号)，命中；</p>
<p>否则，不命中。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/91c7b13cec83.png"></p>
</blockquote>
<h4 id="页式存储小结"><a href="#页式存储小结" class="headerlink" title="页式存储小结"></a>页式存储小结</h4><blockquote>
<ul>
<li>优点： <ul>
<li>解决了碎片问题</li>
<li>便于管理</li>
</ul>
</li>
<li>缺点： <ul>
<li>页表的开销大</li>
<li>共享不便，保护不便：语义边界不清晰</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><blockquote>
<p>每个段可有其逻辑意义及功能，使得便于：编写程序、分段共享、分段保护、动态链接、动态增长。</p>
</blockquote>
<h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote>
<p>用户空间划分</p>
<ul>
<li>按程序自身逻辑关系划分为若干段，如代码段、数据段。 <ul>
<li>可针对不同类型段采取不同的保护</li>
<li>以段为单位共享，包括通过动态链接进行代码共享</li>
</ul>
</li>
<li>每个程序段都有一个段名，且有一个段号</li>
<li>段号从0开始，段内从0开始编址</li>
<li>段内地址是连续的</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/328fd0f1260f.png"></p>
<p>内存空间划分</p>
<ul>
<li>内存空间被动态划分为若干个长度不等的区域，这些区域被称为物理段：(起始地址，长度)</li>
</ul>
</blockquote>
<blockquote>
<p>内存分配</p>
<ul>
<li>以段为单位分配内存，每一个段在内存中占据连续空间</li>
<li>各段之间可以不连续存放</li>
</ul>
</blockquote>
<blockquote>
<p>进程段表</p>
<ul>
<li>段号，段的首址和长度之间的关系。</li>
<li>每一个程序设置一个段表，放在内存，属于进程的<strong>现场</strong> 信息</li>
<li><table>
<thead>
<tr>
<th><strong>段号</strong></th>
<th><strong>基址</strong></th>
<th><strong>长度</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>40K</td>
<td>30K</td>
</tr>
<tr>
<td>1</td>
<td>80K</td>
<td>20K</td>
</tr>
<tr>
<td>2</td>
<td>120K</td>
<td>15K</td>
</tr>
<tr>
<td>3</td>
<td>150K</td>
<td>10K</td>
</tr>
</tbody></table>
</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/e09fba98d97c.png"></li>
</ul>
</blockquote>
<blockquote>
<h4 id="评价"><a href="#评价" class="headerlink" title="[评价]"></a>[评价]</h4><p>优点</p>
<ul>
<li>分段对程序员是可见的，是一种方便的组织程序和数据的手段，便于模块化程序设计</li>
<li>便于保护和共享</li>
</ul>
</blockquote>
<blockquote>
<p>缺点</p>
<ul>
<li>进程全部装入内存</li>
</ul>
</blockquote>
<h4 id="段式地址变换"><a href="#段式地址变换" class="headerlink" title="段式地址变换"></a>段式地址变换</h4><blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/b2bdc3ef4b9c.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/d0d2d05f0c5c.png"></p>
<p>分段系统<strong>共享editor</strong></p>
</blockquote>
<h4 id="分配（类似动态分区）"><a href="#分配（类似动态分区）" class="headerlink" title="分配（类似动态分区）"></a>分配（类似动态分区）</h4><blockquote>
<ul>
<li>系统段表 <ul>
<li>系统内所有占用段</li>
</ul>
</li>
<li>空闲段表 <ul>
<li>记录空闲段起始地址和长度，可以结合到系统段表中</li>
</ul>
</li>
<li>内存分配算法 <ul>
<li>首先适配；最佳适配；最坏适配</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="与分页的比较"><a href="#与分页的比较" class="headerlink" title="与分页的比较"></a>与分页的比较</h4><blockquote>
<ul>
<li>分页是出于系统管理的需要，分段是出于用户应用的需要。</li>
<li>一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。</li>
<li>页大小是系统固定的，而段大小则通常不固定。</li>
<li>逻辑地址表示： 分页是一维的：引用时是统一的地址； 分段是二维的，与程序逻辑一致：引用时段名+偏移；</li>
<li>通常段比页大，因而段表比页表短，查找快，提高访问速度。</li>
<li>段式管理碎片问题比页式管理严重</li>
<li>与动态分区不同：一个程序可以占据多个段，段不要求连续。</li>
</ul>
</blockquote>
<hr>
<h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><blockquote>
<p>分页优点：提高内存利用率</p>
<p>分段优点：方便用户，易于共享，保护，动态链接</p>
<p><strong>段页式系统：综合优点</strong></p>
</blockquote>
<h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><blockquote>
<ul>
<li><p>用户程序按段式划分</p>
</li>
<li><p>内存页式存储管理方案</p>
</li>
<li><p>内存分配：以页为单位进行分配 </p>
<ul>
<li>对用户而言，仍然是二维编址。</li>
<li>对系统而言，则是三维编址</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/a1fa43bb507b.png"></li>
</ul>
</li>
<li><h4 id="地址映射-1"><a href="#地址映射-1" class="headerlink" title="地址映射"></a>地址映射</h4><ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/da31260c8768.png"></li>
</ul>
</li>
<li><h4 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h4><ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/69c4bc4d20e1.png"></li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="地址变换实例"><a href="#地址变换实例" class="headerlink" title="地址变换实例"></a>地址变换实例</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/8e8486c6d7a2.png"></p>
<p>练习：</p>
<blockquote>
<p>设一个地址空间有8个页，每个页面大小为1024个字节，映射到32块物理页面的主存上。试问：</p>
<p>逻辑地址要用多少位表示？13</p>
<p>物理地址要用多少位表示？15 </p>
<p>答：</p>
<p><a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y1nvF9uHu9rHwWP1IWPhmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0Yrjc4rjfsPW6YPHnzP1nLrf" title="逻辑地址">逻辑地址</a>：8<em>1024&#x3D;2^3</em>2^10&#x3D;2^13（所以<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y1nvF9uHu9rHwWP1IWPhmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0Yrjc4rjfsPW6YPHnzP1nLrf" title="逻辑地址">逻辑地址</a>的后13位为“页内地址”，又叫“页内<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E5%81%8F%E7%A7%BB%E9%87%8F&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y1nvF9uHu9rHwWP1IWPhmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0Yrjc4rjfsPW6YPHnzP1nLrf" title="偏移量">偏移量</a>”，或“页内位移”及有效位）</p>
<p>再算<a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y1nvF9uHu9rHwWP1IWPhmv0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnH0Yrjc4rjfsPW6YPHnzP1nLrf" title="物理地址">物理地址</a>：32<em>1024&#x3D;2^5</em>2^10&#x3D;2^15</p>
<p>所以最后的就是逻辑有效位是13；物理有效位是15.</p>
</blockquote>
<hr>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><blockquote>
<p>允许执行只有部分在内存中的程序</p>
<p>程序不受现有物理内存空间限制，用户只对一个大的虚拟地址空间写程序，简化了编程操作</p>
<p>提高程序执行的并发性、CPU利用率</p>
</blockquote>
<hr>
<h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p><strong>常规存储器的问题</strong></p>
<ul>
<li>常规存储 <ul>
<li>一次性，驻留性</li>
<li>覆盖和交换可以减轻这一限制</li>
</ul>
</li>
<li>有时，并不需要将整个程序放入内存中 <ul>
<li>程序中的异常分支</li>
<li>数组通常分配了比实际所需要更多的内存</li>
<li>程序的某些选项或特点可能很少使用</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>虚拟存储器的目标</strong></p>
<ul>
<li>允许执行只有部分在内存中的程序</li>
<li>程序不受现有物理内存空间限制，用户只对一个大的虚拟地址空间写程序，简化了编程操作</li>
<li>提高程序执行的并发性、CPU利用率</li>
</ul>
</blockquote>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><blockquote>
<ul>
<li>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域。</li>
<li>时间局部性（Temporal Locality） <ul>
<li>如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。</li>
</ul>
</li>
<li>空间局部性（Spatial Locality） <ul>
<li>若某一存储单元被使用，则在一定时间内，与该存储单元相邻的单元可能被使用。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><blockquote>
<ul>
<li>具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</li>
<li>逻辑容量由内存容量和外存容量之和所决定 <ul>
<li>运行速度接近于内存速度</li>
<li>成本接近于外存</li>
</ul>
</li>
<li>原理 <ul>
<li>在程序装入时，只需将当前需要执行的部分读入内存，就可让程序开始执行。</li>
<li>在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页或段调入内存，然后继续执行程序。</li>
<li>另一方面，操作系统将内存中暂时不用的页或段调出保存在外存上，腾出空间存放将要调入的页或段。</li>
</ul>
</li>
<li><strong>虚拟内存大于物理内存</strong></li>
<li>实现方法 <ul>
<li>虚拟页式——请求分页(Demand Page) </li>
<li>虚拟段式——请求段式调度(Demand Segmentation) </li>
<li>虚拟段页式</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="虚拟页式"><a href="#虚拟页式" class="headerlink" title="虚拟页式"></a>虚拟页式</h3><blockquote>
<p>在简单页式存储管理的基础上，增加请求调页和页面置换功能。</p>
<h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h4><p>页表：与简单分页相比，增加了如下位：</p>
<p>P：表示该页是否在内存中</p>
<p>A：访问位，是否被访问过</p>
<p>M：修改位，从上次装入到现在是否已经改变</p>
<p>外存地址</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/654b63be8b97.png"></p>
<p>地址转换流程</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/c92de81c37df.png"></p>
<h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="内存分配、置换策略"><a href="#内存分配、置换策略" class="headerlink" title="内存分配、置换策略"></a>内存分配、置换策略</h4><p>分配策略：固定分配，可变分配</p>
<p>置换策略：全局置换，局部置换</p>
<p>可组合出以下三种适用的策略：</p>
<ul>
<li>固定分配局部置换(Fixed Allocation, Local Replacement)</li>
<li>可变分配全局置换(Variable Allocation, Global Replacement)</li>
<li>可变分配局部置换(Variable Allocation, Local Replacement)</li>
</ul>
</blockquote>
<blockquote>
<h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="缺页中断处理"><a href="#缺页中断处理" class="headerlink" title="缺页中断处理"></a>缺页中断处理</h4><ul>
<li><p>要访问的页不在内存，则产生缺页中断(page fault)。</p>
</li>
<li><p>操作系统接到此中断信号后，调用缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使作业继续运行下去 </p>
<ul>
<li>如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的驻留位及相应的内存块号</li>
<li>若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存</li>
</ul>
</li>
<li><p>缺页中断在指令执行期间产生和处理，所缺的页面调入之后，重新执行被中断的指令。</p>
</li>
<li><h4 id="系统颠簸-抖动"><a href="#系统颠簸-抖动" class="headerlink" title="系统颠簸&#x2F;抖动"></a>系统颠簸&#x2F;抖动</h4><ul>
<li>页面被频繁地换入换出</li>
<li>缺页率急剧增加，内存有效存取时间加长，系统吞吐量骤减；</li>
<li>系统已基本不能完成什么任务。</li>
<li>原因：CPU利用率太低→调度程序增加多道程序度→新进程启动运行→内存不足→缺页→I&#x2F;O忙碌，CPU空闲。</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/8315f174d0d8.png"></li>
<li>防止系统颠簸&#x2F;抖动 <ul>
<li>局部置换策略：如果一个进程出现抖动，它不能从另外的进程取帧。</li>
<li>挂起某些进程：优先级低、缺页进程、最大的进程等</li>
<li>利用工作集、缺页频率策略防止抖动</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h4><ul>
<li>一个进程在某一段时间内访问页面的集合。（<strong>并非越大越好</strong> ！）</li>
<li>如果页面正在使用，它就落在工作集中；</li>
<li>如果不再使用，它将不出现在相应的工作集中，所以，工作集是程序局部性的近似表示。</li>
<li>工作集：W(t, Δt)，(t-Δt, t] 内访问的页面集合。</li>
<li>虚拟时间t：页面访问点</li>
<li>时间窗口Δt <ul>
<li>太小，不能包含整个局部；</li>
<li>太大，是进程执行所碰到的所有页的集合。</li>
</ul>
</li>
<li>避免抖动方法 <ul>
<li>OS监视每个进程的工作集 <ul>
<li>新增页面分配内存。</li>
<li>淘汰不在工作集中的页面。</li>
</ul>
</li>
<li>若有足够多的额外内存块，就可装入另一个进程。</li>
<li>如果所有工作集之和超过了可用内存，则OS选择挂起一个进程，把它的页换出，将其内存块分配给其它进程。</li>
<li>工作集的估算不容易：Δ</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="页面替换-置换算法"><a href="#页面替换-置换算法" class="headerlink" title="页面替换&#x2F;置换算法"></a>页面替换&#x2F;置换算法</h3><blockquote>
<h4 id="最佳算法（OPT）"><a href="#最佳算法（OPT）" class="headerlink" title="最佳算法（OPT）"></a>最佳算法（OPT）</h4><p>选择替换下次访问距当前时间最长的那些页。</p>
<p><strong>特点</strong></p>
<ul>
<li>缺页错误率最低，没有Belady现象；</li>
<li>必须知道页面未来的访问顺序→不可能实现。</li>
<li>仅作为一种标准，用于测试其他算法的性能。</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/13ef06e56b5d.png"></p>
<h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><h4 id="先进先出算法-First-in-First-Out，FIFO"><a href="#先进先出算法-First-in-First-Out，FIFO" class="headerlink" title="先进先出算法(First in First Out，FIFO)"></a>先进先出算法(First in First Out，FIFO)</h4><p>替换驻留在主存中时间最长的页</p>
<p>注意：驻留时间和访问时间无关</p>
<p>实现：将分配给进程的页帧看作FIFO队列，按循环方式移动页：置换队列的首页，调入的新页加入队尾。</p>
<p>问题：FIFO策略实现简单，但性能相对较差。</p>
<p>Belady异常：有些情况下，缺页率可能会随着所分配帧数的增加而增加。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/61d07bbb06d8.png"></p>
<p><strong>练习：</strong></p>
<p>页面请求序列：3 2 1 0 3 2 4 3 2 1 0 4 分别计算使用FIFO算法，分配3个Frame和4个Frame时产生page fault的次数。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/544d2492e833.png"></p>
<h4 id="-5"><a href="#-5" class="headerlink" title=""></a></h4><h4 id="最近最久未使用算法-LRU-Least-Recently-Used"><a href="#最近最久未使用算法-LRU-Least-Recently-Used" class="headerlink" title="最近最久未使用算法(LRU, Least Recently Used)"></a>最近最久未使用算法(LRU, Least Recently Used)</h4><p>替换主存中上次使用距离当前最远的页（最长时间没有使用的页）</p>
<p>可以理解为向后看最优置换算法：根据局部性原理，这也是最近最不可能访问到的页。</p>
<p>性能接近OPT，但历史不等于未来</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/66265a4bec07.png"></p>
<ul>
<li>实现： <ul>
<li>计数器：每个页添加逻辑时钟或计数器，访问页面时加1，定时减1（或寄存器移位）。在淘汰时，选择该值最小的页面。 <ul>
<li>比较开销</li>
</ul>
</li>
<li>堆栈：页面被访问，该页就从堆栈中提到顶部，底部是目前最少使用的页。 <ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/61f54429c02d.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="-6"><a href="#-6" class="headerlink" title=""></a></h4><h4 id="Clock算法"><a href="#Clock算法" class="headerlink" title="Clock算法"></a>Clock算法</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/5ecd9bd3d7f3.png"></p>
<h4 id="改进Clock算法"><a href="#改进Clock算法" class="headerlink" title="改进Clock算法"></a>改进Clock算法</h4><p>增加修改位M</p>
<p>由(A, M)可以组合成四种页面：</p>
<p>(A&#x3D;0, M&#x3D;0)：表示该页最近既未被访问，又未被修改， 是最佳淘汰页。</p>
<p>(A&#x3D;0, M&#x3D;1)：表示该页最近未被访问，但已被修改，若替换要被写回。</p>
<p>(A&#x3D;1, M&#x3D;0)：最近已被访问，但未被修改，该页有可能再被访问。</p>
<p>(A&#x3D;1, M&#x3D;1)：最近已被访问且被修改，该页可能再被访问。</p>
<p><strong>步骤：</strong></p>
<p>从指针所指示的当前位置开始，扫描循环队列， 寻找(A&#x3D;0, M&#x3D;0)的第一类页面，将遇到的第一个页面作为淘汰页，如未找到，转第2步；</p>
<p>同样扫描方法，寻找(A&#x3D;0, M&#x3D;1)的第二类页面，将遇到的第一个此类页面作为淘汰页。将所有扫描过的页面的访问位A置0。若未找到，转第1步。 </p>
<h4 id="其他置换算法"><a href="#其他置换算法" class="headerlink" title="其他置换算法"></a>其他置换算法</h4><ul>
<li>最不经常使用算法LFU(Least Frequently Used) <ul>
<li>访问频繁→访问记数大 <ul>
<li>例外：一个页在进程开始时使用得很多，但以后就不再使用</li>
</ul>
</li>
<li>定期将次数寄存器右移一位，形成指数衰减</li>
<li>关注访问次数，LRU关注上次访问时间</li>
</ul>
</li>
<li>最常使用算法MFU(Most Frequently Used) <ul>
<li>最小次数的页可能刚刚调进来，且还没有使用，不换出</li>
</ul>
</li>
<li>页面缓冲算法PBA(Page Buffering Algorithm) <ul>
<li>维护一个free page pool</li>
<li>换出页可稍后换出，避免调入时换出写磁盘</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h4><h4 id="-7"><a href="#-7" class="headerlink" title=""></a><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/a1ee42be2655.png"></h4><hr>
<h3 id="虚拟段式"><a href="#虚拟段式" class="headerlink" title="虚拟段式"></a>虚拟段式</h3><blockquote>
<h4 id="请求分段"><a href="#请求分段" class="headerlink" title="请求分段"></a>请求分段</h4><ul>
<li>在简单段式存储管理的基础上，增加请求调段和段置换功能。</li>
<li>段表添加若干项： <ul>
<li>存在位(present bit)</li>
<li>修改位(modified bit&#x2F;dirty bit)</li>
<li>访问&#x2F;使用位(use bit)</li>
<li>存取权限：如读R，写W，执行X</li>
<li>外存地址</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/d08a9d451508.png"></p>
<ul>
<li>动态地址变换和缺段中断：指令和操作数必定不会跨越在段边界上</li>
<li>程序运行时，先把当前需要的一段或者几段装入内存，其它段仅仅在调用时才装入。</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/86e05bc96d90.png"></li>
</ul>
</blockquote>
<blockquote>
<h4 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/1d25cc7e61e9.png"></p>
</blockquote>
<hr>
<h3 id="虚拟段页式"><a href="#虚拟段页式" class="headerlink" title="虚拟段页式"></a>虚拟段页式</h3><blockquote>
<ul>
<li>虚拟段页式：虚拟页式和虚拟段式存储管理的结合，存储管理的分配单位是：段，页</li>
<li>逻辑地址的组成：段号，页号，页内偏移地址，程序员可见的仍是段号和段内相对地址。</li>
<li>地址变换：先查段表，再查该段的页表。缺段中断和缺页中断。</li>
</ul>
</blockquote>
<h4 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h4><ul>
<li>共享段表：整个系统一张 <ul>
<li>共享进程计数，存取控制字段。</li>
<li>段号：不同进程可以使用不同的段号共享段。</li>
</ul>
</li>
<li><table>
<thead>
<tr>
<th>段名</th>
<th>段长</th>
<th>内存地址</th>
<th>状态</th>
<th>外存地址</th>
</tr>
</thead>
<tbody><tr>
<td>共享进程计数</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>状态</td>
<td>进程名</td>
<td>进程号</td>
<td>段号</td>
<td>存取控制</td>
</tr>
<tr>
<td>… … … … …</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>存储器管理部分告一段落，本章主要任务就是理解一些概念，重点在于熟练运用各种算法进行计算，例如<strong>重定位、地址变换、计算页表存储空间、页面置换算法</strong> 等。 </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/veckun">Likun Wang (王立坤)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://your-domain.com/2023/02/14/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/">https://your-domain.com/2023/02/14/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/">存储器管理</a><a class="post-meta__tags" href="/tags/%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E6%AE%B5%E9%A1%B5%E5%BC%8F/">页式段式段页式</a><a class="post-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8/">虚拟存储</a></div><div class="post-share"><div class="social-share" data-image="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png" data-sites="wechat,weibo,qq,twitter,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/02/15/en/UESTC-OS-Notes-4-Device-Management/" title="UESTC Operating System Review Notes (4): Device Management"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/aa55f8cf800b.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">UESTC Operating System Review Notes (4): Device Management</div></div><div class="info-2"><div class="info-item-1">Table of Contents PrefaceDevice ManagementI&#x2F;O SystemDevice ClassificationDevice ControllersI&#x2F;O ChannelsI&#x2F;O Control MethodsBuffer ManagementI&#x2F;O SoftwareDevice AllocationSPOOLingDisk StorageDisk StructureDisk AccessDisk Scheduling AlgorithmsDisk ManagementRAID  PrefaceThis review note focuses on CM4: Device Management - I&#x2F;O system structure, buffer management, disk structure, and disk scheduling algorithms.  Device ManagementI&#x2F;O SystemBasic Concepts From OS perspec...</div></div></div></a><a class="pagination-related" href="/2023/02/14/en/UESTC-OS-Notes-3-Memory-Management/" title="UESTC Operating System Review Notes (3): Memory Management"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">UESTC Operating System Review Notes (3): Memory Management</div></div><div class="info-2"><div class="info-item-1">Table of Contents PrefaceMemory Management OverviewStorage System StructureProgram Birth ProcessAddress SpacesAddress MappingProgram Linking MethodsProgram Loading MethodsContiguous AllocationSingle Contiguous AllocationPartition ManagementFixed Partition AllocationDynamic Partition AllocationPartition Allocation AlgorithmsOverlay and SwappingDiscrete AllocationPaged Storage ManagementAddress TranslationPage TablesTwo-Level and Multi-Level Page TablesInverted Page TablesSegmented Storage Mana...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/02/18/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="电子科技大学操作系统期末复习笔记（五）：文件管理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://latex.csdn.net/eq?%5Cleftrightarrow" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-19</div><div class="info-item-2">电子科技大学操作系统期末复习笔记（五）：文件管理</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（五）：文件管理📊 2835 阅读 | 👍 16 点赞 | 💬 9 评论 | ⭐ 47 收藏  目录 前言 文件管理：基础 基本概念 文件 文件系统 文件系统的实现模型 文件的组成 文件名 文件分类 文件结构 逻辑结构 物理结构 练习题  文件管理：目录 文件控制块FCB FCB：File Control Block FCB信息 目录 基本概念 目录功能 目录基本操作 ⭐FCB组织方法 ⭐改进的FCB组织方法 目录的组织 路径 无环图目录 链接 通用图目录 文件管理：磁盘管理 空闲分区表 概念 特点  空闲分区链表 概念 特点 位示图 成组块链接法 分配方法 释放方法 例题 文件一致性：盘块 链接数一致性检查 文件执行 数据结构 文件共享 文件操作 执行过程 虚拟文件系统 VFS  前言设备管理模块已经更新，传送门：电子科技大学操作系统期末复习笔记（四）：设备管理 本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：   CM1： 操作系统概念。操作系统基本功...</div></div></div></a><a class="pagination-related" href="/2023/02/15/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" title="电子科技大学操作系统期末复习笔记（四）：设备管理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/aa55f8cf800b.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-16</div><div class="info-item-2">电子科技大学操作系统期末复习笔记（四）：设备管理</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（四）：设备管理📊 1395 阅读 | 👍 8 点赞 | 💬 1 评论 | ⭐ 20 收藏  目录 前言 设备管理 I&#x2F;O系统 基本概念 设备使用特性 数据传输速率 数据传输单位 设备共享属性 设备控制器 I&#x2F;O通道 I&#x2F;O控制方式 程序I&#x2F;O控制方式 中断方式 直接存储器访问（DMA）  缓冲管理 单缓冲Single Buffer 双缓冲Double Buffer 循环缓冲Circular Buffer 缓冲池Buffer Pool I&#x2F;O软件 中断的工作方式 设备分配 设备分配算法 SPOOLing：假脱机操作 设备管理：调度与实例  磁盘存储器 基本概念 磁盘结构 地址转换 连接方式 DAS：磁盘挂载 NAS：网络挂载 SAN：存储区域网 磁盘访问 访问模式 访问时间 寻道时间 传输时间 (旋转)延迟时间 总访问时间 磁盘调度 先来先服务（FCFS） 最短寻道时间优先（SSTF） 扫描算法（SCAN, CSCAN） Look &amp; C-Look算法...</div></div></div></a><a class="pagination-related" href="/2023/02/13/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" title="电子科技大学操作系统期末复习笔记（二）：进程与并发控制"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e94870088ab1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-14</div><div class="info-item-2">电子科技大学操作系统期末复习笔记（二）：进程与并发控制</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（二）：进程与并发控制📊 2513 阅读 | 👍 18 点赞 | 💬 2 评论 | ⭐ 47 收藏  目录 前言 进程管理 进程基本知识 程序的顺序执行 前趋图 程序的并发执行 并发程序 进程的定义和特征  进程的特征和状态 操作系统内核 定义 功能 原语 原子操作的实现  操作系统控制结构 进程控制块PCB 进程组织（进程树） 进程的创建 进程控制函数（fork与exec为主） 进程的终止 进程切换 线程 与进程的区别和联系 线程的优势 线程的特点 线程的状态 线程的分类 处理机调度 ⭐单处理机调度（重点） 调度原则 调度算法：资源分配问题 先来先服务：FCFS 短作业优先：SPF&#x2F;SJF 时间片轮转调度：TSRR 最短剩余时间调度：SRT 基于优先权&#x2F;优先级的调度算法 高响应比优先算法：HRRN 多级队列调度算法 多级反馈队列调度：MFQ 总结 实时调度  基本条件 系统处理能力下界 实时调度算法 多处理机调度 分类 进程分配方式 单队列多处理机调度 多队列多处理机调度 成组调度 专用...</div></div></div></a><a class="pagination-related" href="/2023/02/26/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%94%9F%E4%BA%A7%E7%8E%87%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%BA%A6%E9%87%8F/" title="电子科技大学软件工程期末复习笔记（五）：生产率和工作度量"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E7%94%9F%E4%BA%A7%E7%8E%87%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%BA%A6%E9%87%8F/abaa1253c9cb.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="info-item-2">电子科技大学软件工程期末复习笔记（五）：生产率和工作度量</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学软件工程期末复习笔记（五）：生产率和工作度量📊 1970 阅读 | 👍 12 点赞 | 💬 1 评论 | ⭐ 27 收藏  目录 前言 重点一览 软件产品度量 测量软件生产率的两种方法 基于LOC测量 例题： 优点 缺点 基于功能点测量 例题： 本章小结  前言本复习笔记基于王玉林老师的课堂PPT与复习大纲，供自己期末复习与学弟学妹参考用。  重点一览 这一部分内容较少，但涉及到了计算问题，所以也应重视。  软件产品度量 一种量化衡量方法，使得人们可以理解和把握软件项目的生产效率或者所需要的劳动量。 目的：描述项目和过程、评估状态和质量、预测为计划、改进产品质量和过程性能。   测量软件生产率的两种方法 软件生产率测量的两种方式： 直接测量：基于LOC（一定时间产生的代码行数） 间接测量：基于功能点（给定时间内产出的功能点目标点）  基于LOC测量 例题： 优点 LOC、KLOC和相关度量容易计算 许多现有的软件估算模型都使用LOC和KLOC作为一项重要输入 有大量的关于LOC的文献和数据    缺点 LOC依赖于使用的语言，这...</div></div></div></a><a class="pagination-related" href="/2023/02/11/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="电子科技大学操作系统期末复习笔记（一）：操作系统概述"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/5e52ba583b39.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="info-item-2">电子科技大学操作系统期末复习笔记（一）：操作系统概述</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（一）：操作系统概述📊 2672 阅读 | 👍 23 点赞 | 💬 2 评论 | ⭐ 50 收藏  目录 前言 操作系统概述 操作系统的目标与功能 操作系统的定义 目标 功能 操作系统的历史 单用户系统 简单批处理系统 多道批处理系统 分时系统 个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → …… 实时系统 操作系统的基本特征 并发 共享 虚拟 不确定性 操作系统的体系结构 无结构操作系统 模块化系统结构 分层式系统结构 操作系统安全 内存 信息保护和安全  前言本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：   CM1： 操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。  CM2： 进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。  CM3： 内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理...</div></div></div></a><a class="pagination-related" href="/2023/02/26/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" title="电子科技大学软件工程期末复习笔记（四）：软件设计"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/77745a059f08.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="info-item-2">电子科技大学软件工程期末复习笔记（四）：软件设计</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学软件工程期末复习笔记（四）：软件设计📊 2741 阅读 | 👍 13 点赞 | 💬 4 评论 | ⭐ 45 收藏  目录 前言 重点一览 软件工程设计 软件设计定义 软件设计包含的两类活动 软件设计包涵 软件的质量属性 各种设计技术 程序结构(深度、宽度、扇入、扇出) 完整的设计规格 软件体系架构 用户界面设计的3条原则 用户界面设计的3种分析 结构化设计方法 结构化程序设计的概念  流程图 程序流程图的主要缺点： 伪代码 NS图 PAD图 本章小结  前言本复习笔记基于王玉林老师的课堂PPT与复习大纲，供自己期末复习与学弟学妹参考用。  重点一览 分为两个部分讲解： 软件设计工程和结构化设计方法  软件工程设计软件设计定义软件设计定义为软件的架构、构件、接口和其他特性的定义过程及该过程的结果。  软件设计是：  软件工程生命周期中的一个活动 进行软件编码的基础 软件需求分析被转化为软件的内部结构 是连接用户需求和软件技术的桥梁   软件设计包含的两类活动 软件架构设计  又叫“概要设计”、“顶层设计” 描述软件的顶层架构和组织...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Likun Wang (王立坤)</div><div class="author-info-description">Algorithm Engineer | AI Engineer
Waseda University M.E.
Deep Learning & TPU Development
</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">302</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">311</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/veckun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/veckun" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:vector_kun@ruri.waseda.jp" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://linkedin.com/in/veckun" target="_blank" title="LinkedIn"><i class="fab fa-linkedin" style="color: #0077b5;"></i></a><a class="social-icon" href="javascript:void(0)" target="_blank" title="WeChat vectorkun"><i class="fab fa-weixin" style="color: #07c160;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_59180666" target="_blank" title="CSDN"><i class="fab fa-blogger" style="color: #fc5531;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcome to my blog! Sharing AI, algorithms & tech insights.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">2.1.1.</span> <span class="toc-text">存储管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">存储系统的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">2.1.3.</span> <span class="toc-text">程序的诞生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.4.</span> <span class="toc-text">空间分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">2.1.5.</span> <span class="toc-text">地址映射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">程序链接的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">装入时动态链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.3.</span> <span class="toc-text">运行时动态链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">程序装入的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%A3%85%E5%85%A5%E7%9A%84%E4%B8%A4%E7%B1%BB%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">程序装入的两类三种方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5"><span class="toc-number">2.3.2.</span> <span class="toc-text">绝对装入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.3.3.</span> <span class="toc-text">静态重定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D%E2%88%9A"><span class="toc-number">2.3.4.</span> <span class="toc-text">动态重定位√</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">2.3.5.</span> <span class="toc-text">关键点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%9A%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">3.</span> <span class="toc-text">存储器管理：连续分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">3.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">分区管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">3.2.2.</span> <span class="toc-text">[放置算法（分配算法）]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.2.3.</span> <span class="toc-text">动态分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.4.</span> <span class="toc-text">常用分区分配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%85%88%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.5.</span> <span class="toc-text">[最先适配算法]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%9C%80%E5%85%88%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.6.</span> <span class="toc-text">[循环最先适配算法]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.7.</span> <span class="toc-text">[最佳适配算法]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.8.</span> <span class="toc-text">[最坏适配算法]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.9.</span> <span class="toc-text">[伙伴系统]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98%EF%BC%9A%E7%B4%A7%E5%87%91-%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.2.10.</span> <span class="toc-text">[碎片问题：紧凑&#x2F;动态重定位]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.11.</span> <span class="toc-text">动态分区分配算法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">3.3.</span> <span class="toc-text">覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.3.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.3.4.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2-%E5%AF%B9%E6%8D%A2"><span class="toc-number">3.4.</span> <span class="toc-text">交换&#x2F;对换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">3.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%B2%92%E5%BA%A6"><span class="toc-number">3.4.2.</span> <span class="toc-text">交换粒度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.3.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%8E%E8%A6%86%E7%9B%96%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.4.4.</span> <span class="toc-text">交换与覆盖的比较</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%EF%BC%9A%E7%A6%BB%E6%95%A3%E5%88%86%E9%85%8D"><span class="toc-number">4.</span> <span class="toc-text">存储器管理：离散分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.2.</span> <span class="toc-text">[分页逻辑地址结构]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.1.3.</span> <span class="toc-text">[基本页式存储管理]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.1.4.</span> <span class="toc-text">[地址变换机构]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.1.5.</span> <span class="toc-text">页式存储中的重定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E9%87%8D%E7%82%B9%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">4.1.6.</span> <span class="toc-text">⭐重点计算方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">4.1.7.</span> <span class="toc-text">具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-number">4.1.8.</span> <span class="toc-text">[快表]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">4.1.9.</span> <span class="toc-text">计算页表存储空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E5%92%8C%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.1.10.</span> <span class="toc-text">两级和多级页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">4.1.11.</span> <span class="toc-text">[例题]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="toc-number">4.1.12.</span> <span class="toc-text">反置页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E5%B0%8F%E7%BB%93"><span class="toc-number">4.1.13.</span> <span class="toc-text">页式存储小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">段式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-number">4.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7"><span class="toc-number">4.2.2.</span> <span class="toc-text">[评价]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">4.2.3.</span> <span class="toc-text">段式地址变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E9%85%8D%EF%BC%88%E7%B1%BB%E4%BC%BC%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%EF%BC%89"><span class="toc-number">4.2.4.</span> <span class="toc-text">分配（类似动态分区）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.5.</span> <span class="toc-text">与分页的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">段页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">4.3.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">地址映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">4.3.3.</span> <span class="toc-text">地址变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.4.</span> <span class="toc-text">地址变换实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-4"><span class="toc-number">5.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">局部性原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">5.1.2.</span> <span class="toc-text">虚拟内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E9%A1%B5%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">虚拟页式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#-1"><span class="toc-number">5.2.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5"><span class="toc-number">5.2.2.</span> <span class="toc-text">请求分页</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-2"><span class="toc-number">5.2.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E3%80%81%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.4.</span> <span class="toc-text">内存分配、置换策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-3"><span class="toc-number">5.2.5.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">5.2.6.</span> <span class="toc-text">缺页中断处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%A2%A0%E7%B0%B8-%E6%8A%96%E5%8A%A8"><span class="toc-number">5.2.7.</span> <span class="toc-text">系统颠簸&#x2F;抖动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86"><span class="toc-number">5.2.8.</span> <span class="toc-text">工作集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%9B%BF%E6%8D%A2-%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">页面替换&#x2F;置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%AE%97%E6%B3%95%EF%BC%88OPT%EF%BC%89"><span class="toc-number">5.3.1.</span> <span class="toc-text">最佳算法（OPT）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-4"><span class="toc-number">5.3.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AE%97%E6%B3%95-First-in-First-Out%EF%BC%8CFIFO"><span class="toc-number">5.3.3.</span> <span class="toc-text">先进先出算法(First in First Out，FIFO)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-5"><span class="toc-number">5.3.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95-LRU-Least-Recently-Used"><span class="toc-number">5.3.5.</span> <span class="toc-text">最近最久未使用算法(LRU, Least Recently Used)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-6"><span class="toc-number">5.3.6.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Clock%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.7.</span> <span class="toc-text">Clock算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9BClock%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.8.</span> <span class="toc-text">改进Clock算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.9.</span> <span class="toc-text">其他置换算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">5.3.10.</span> <span class="toc-text">练习题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#-7"><span class="toc-number">5.3.11.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%AE%B5%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">虚拟段式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E6%AE%B5"><span class="toc-number">5.4.1.</span> <span class="toc-text">请求分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">5.4.2.</span> <span class="toc-text">地址变换过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">虚拟段页式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%9A%84%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">5.5.1.</span> <span class="toc-text">分段的共享与保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/04/en/Kiro-Batch-Registration-Vulnerability-Whistleblower/" title="On 'I Report Myself': The 'Modern-Day Hero' Behind Kiro's Batch Registration Vulnerability"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/kiro-whistleblower.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="On 'I Report Myself': The 'Modern-Day Hero' Behind Kiro's Batch Registration Vulnerability"/></a><div class="content"><a class="title" href="/2026/01/04/en/Kiro-Batch-Registration-Vulnerability-Whistleblower/" title="On 'I Report Myself': The 'Modern-Day Hero' Behind Kiro's Batch Registration Vulnerability">On 'I Report Myself': The 'Modern-Day Hero' Behind Kiro's Batch Registration Vulnerability</a><time datetime="2026-01-04T15:00:00.000Z" title="Created 2026-01-05 00:00:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/04/zh-CN/%E8%AE%BA%E3%80%8A%E6%88%91-%E4%B8%BE-%E6%8A%A5-%E6%88%91-%E8%87%AA-%E5%B7%B1%E3%80%8B%EF%BC%9AKiro-%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E6%BC%8F%E6%B4%9E%E8%83%8C%E5%90%8E%E7%9A%84%E2%80%9C%E5%BD%93%E4%BB%A3%E6%B4%BB%E9%9B%B7%E9%94%8B%E2%80%9D/" title="论《我 举 报 我 自 己》：Kiro 批量注册漏洞背后的&quot;当代活雷锋&quot;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/kiro-whistleblower.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论《我 举 报 我 自 己》：Kiro 批量注册漏洞背后的&quot;当代活雷锋&quot;"/></a><div class="content"><a class="title" href="/2026/01/04/zh-CN/%E8%AE%BA%E3%80%8A%E6%88%91-%E4%B8%BE-%E6%8A%A5-%E6%88%91-%E8%87%AA-%E5%B7%B1%E3%80%8B%EF%BC%9AKiro-%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E6%BC%8F%E6%B4%9E%E8%83%8C%E5%90%8E%E7%9A%84%E2%80%9C%E5%BD%93%E4%BB%A3%E6%B4%BB%E9%9B%B7%E9%94%8B%E2%80%9D/" title="论《我 举 报 我 自 己》：Kiro 批量注册漏洞背后的&quot;当代活雷锋&quot;">论《我 举 报 我 自 己》：Kiro 批量注册漏洞背后的&quot;当代活雷锋&quot;</a><time datetime="2026-01-04T15:00:00.000Z" title="Created 2026-01-05 00:00:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/12/en/Common-Archive-Formats-Explained/" title="Common Archive Formats Explained: Differences and Extraction Methods"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Common Archive Formats Explained: Differences and Extraction Methods"/></a><div class="content"><a class="title" href="/2025/10/12/en/Common-Archive-Formats-Explained/" title="Common Archive Formats Explained: Differences and Extraction Methods">Common Archive Formats Explained: Differences and Extraction Methods</a><time datetime="2025-10-12T15:00:00.000Z" title="Created 2025-10-13 00:00:00">2025-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/12/zh-CN/%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E6%96%B9%E5%BC%8F/" title="常见压缩包格式详解：区别及在不同系统中的解压方式"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见压缩包格式详解：区别及在不同系统中的解压方式"/></a><div class="content"><a class="title" href="/2025/10/12/zh-CN/%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E6%96%B9%E5%BC%8F/" title="常见压缩包格式详解：区别及在不同系统中的解压方式">常见压缩包格式详解：区别及在不同系统中的解压方式</a><time datetime="2025-10-12T15:00:00.000Z" title="Created 2025-10-13 00:00:00">2025-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/en/Master-Python-Debugger-pdb-in-10-Minutes/" title="Master Python Debugger pdb in 10 Minutes"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/10%E5%88%86%E9%92%9F%E6%8E%8C%E6%8F%A1Python%E8%B0%83%E8%AF%95%E5%99%A8pdb/0d565b653736.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Master Python Debugger pdb in 10 Minutes"/></a><div class="content"><a class="title" href="/2025/09/18/en/Master-Python-Debugger-pdb-in-10-Minutes/" title="Master Python Debugger pdb in 10 Minutes">Master Python Debugger pdb in 10 Minutes</a><time datetime="2025-09-18T15:00:00.000Z" title="Created 2025-09-19 00:00:00">2025-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Likun Wang (王立坤)</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div><div class="footer_custom_text"><p>Likun Wang | Algorithm Engineer</p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'ams',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://your-twikoo.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://your-twikoo.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/lang-router.js"></script><script src="/js/csdn-stats.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="local-search-input"><input placeholder="Search..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>