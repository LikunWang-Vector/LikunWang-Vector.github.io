<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>电子科技大学操作系统期末复习笔记（二）：进程与并发控制 | Likun Wang | 王立坤</title><meta name="author" content="Likun Wang (王立坤)"><meta name="copyright" content="Likun Wang (王立坤)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（二）：进程与并发控制📊 2513 阅读 | 👍 18 点赞 | 💬 2 评论 | ⭐ 47 收藏  目录 前言 进程管理 进程基本知识 程序的顺序执行 前趋图 程序的并发执行 并发程序 进程的定义和特征  进程的特征和状态 操作系统内核 定义 功能 原语 原子操作的实现  操作系统控制结构 进程控制块PCB 进程组织（进程树">
<meta property="og:type" content="article">
<meta property="og:title" content="电子科技大学操作系统期末复习笔记（二）：进程与并发控制">
<meta property="og:url" content="https://your-domain.com/2023/02/13/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/index.html">
<meta property="og:site_name" content="Likun Wang | 王立坤">
<meta property="og:description" content="本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（二）：进程与并发控制📊 2513 阅读 | 👍 18 点赞 | 💬 2 评论 | ⭐ 47 收藏  目录 前言 进程管理 进程基本知识 程序的顺序执行 前趋图 程序的并发执行 并发程序 进程的定义和特征  进程的特征和状态 操作系统内核 定义 功能 原语 原子操作的实现  操作系统控制结构 进程控制块PCB 进程组织（进程树">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://your-domain.com/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e94870088ab1.png">
<meta property="article:published_time" content="2023-02-13T15:00:00.000Z">
<meta property="article:modified_time" content="2023-02-13T15:00:00.000Z">
<meta property="article:author" content="Likun Wang (王立坤)">
<meta property="article:tag" content="复习笔记">
<meta property="article:tag" content="并发控制">
<meta property="article:tag" content="操作系统">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="进程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://your-domain.com/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e94870088ab1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "电子科技大学操作系统期末复习笔记（二）：进程与并发控制",
  "url": "https://your-domain.com/2023/02/13/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/",
  "image": "https://your-domain.com/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e94870088ab1.png",
  "datePublished": "2023-02-13T15:00:00.000Z",
  "dateModified": "2023-02-13T15:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "Likun Wang (王立坤)",
      "url": "https://github.com/veckun"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://your-domain.com/2023/02/13/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.3"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Likun Wang (王立坤)","link":"Link: ","source":"Source: Likun Wang | 王立坤","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '电子科技大学操作系统期末复习笔记（二）：进程与并发控制',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/csdn-stats.css"><link rel="stylesheet" href="/css/lang-switch.css"><meta name="generator" content="Hexo 8.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">302</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">311</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">21</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/cv/"><i class="fa-fw fas fa-graduation-cap"></i><span> CV</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e94870088ab1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Likun Wang | 王立坤</span></a><a class="nav-page-title" href="/"><span class="site-name">电子科技大学操作系统期末复习笔记（二）：进程与并发控制</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/cv/"><i class="fa-fw fas fa-graduation-cap"></i><span> CV</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">电子科技大学操作系统期末复习笔记（二）：进程与并发控制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-02-13T15:00:00.000Z" title="Created 2023-02-14 00:00:00">2023-02-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-02-13T15:00:00.000Z" title="Updated 2023-02-14 00:00:00">2023-02-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">复习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>44mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:180,&quot;messagePrev&quot;:&quot;This article was last updated&quot;,&quot;messageNext&quot;:&quot;days ago. The content may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-02-14 00:00:00&quot;}" hidden></div><blockquote>
<p>本文迁移自CSDN博客<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59180666/article/details/128996730">电子科技大学操作系统期末复习笔记（二）：进程与并发控制</a><br>📊 2513 阅读 | 👍 18 点赞 | 💬 2 评论 | ⭐ 47 收藏</p>
</blockquote>
<p><strong>目录</strong></p>
<p>前言</p>
<p>进程管理</p>
<p>进程基本知识</p>
<p>程序的顺序执行</p>
<p>前趋图</p>
<p>程序的并发执行</p>
<p>并发程序</p>
<p>进程的定义和特征 </p>
<p>进程的特征和状态</p>
<p>操作系统内核</p>
<p>定义</p>
<p>功能</p>
<p>原语</p>
<p>原子操作的实现 </p>
<p>操作系统控制结构</p>
<p>进程控制块PCB</p>
<p>进程组织（进程树）</p>
<p>进程的创建</p>
<p>进程控制函数（fork与exec为主）</p>
<p>进程的终止</p>
<p>进程切换</p>
<p>线程</p>
<p>与进程的区别和联系</p>
<p>线程的优势</p>
<p>线程的特点</p>
<p>线程的状态</p>
<p>线程的分类</p>
<p>处理机调度</p>
<p>⭐单处理机调度（重点）</p>
<p>调度原则</p>
<p>调度算法：资源分配问题</p>
<p>先来先服务：FCFS</p>
<p>短作业优先：SPF&#x2F;SJF</p>
<p>时间片轮转调度：TSRR</p>
<p>最短剩余时间调度：SRT</p>
<p>基于优先权&#x2F;优先级的调度算法</p>
<p>高响应比优先算法：HRRN</p>
<p>多级队列调度算法</p>
<p>多级反馈队列调度：MFQ</p>
<p>总结</p>
<p>实时调度 </p>
<p>基本条件</p>
<p>系统处理能力下界</p>
<p>实时调度算法</p>
<p>多处理机调度</p>
<p>分类</p>
<p>进程分配方式</p>
<p>单队列多处理机调度</p>
<p>多队列多处理机调度</p>
<p>成组调度</p>
<p>专用处理机分配 </p>
<p>进程并发控制：互斥与同步</p>
<p>进程&#x2F;线程的并发控制</p>
<p>基本概念</p>
<p>同步的解决策略</p>
<p>软件方法</p>
<p>硬件方法</p>
<p>信号量</p>
<p>管程</p>
<p>⭐进程并发控制：信号量的应用（重点）</p>
<p>观察者问题</p>
<p>图书馆问题</p>
<p>公交车问题</p>
<p>⭐生产者&#x2F;消费者问题（重点）</p>
<p>例题：</p>
<p>启示</p>
<p>⭐读&#x2F;写者问题（重点）</p>
<p>读者优先</p>
<p>写者优先</p>
<p>公平优先</p>
<p>⭐理发师问题（重点）</p>
<p>⭐哲学家问题（重点）</p>
<p>重点知识点回顾</p>
<p>进程并发控制：练习题</p>
<p>问题1</p>
<p>问题2</p>
<p>问题3</p>
<p>问题4</p>
<p>问题5</p>
<p>问题6</p>
<p>问题7</p>
<p>问题8 </p>
<p>问题9</p>
<p>进程间通信</p>
<p>基本概念</p>
<p>消息传递</p>
<p>管道（Pipe）通信</p>
<p>死锁 </p>
<p>产生死锁的原因</p>
<p>系统模型</p>
<p>资源类型</p>
<p>资源分配图</p>
<p>实例</p>
<p>死锁的充要条件 </p>
<p>处理死锁的基本方法 </p>
<p>死锁预防</p>
<p>死锁避免</p>
<p>死锁检测</p>
<p>死锁解除</p>
<p>死锁忽略</p>
<p>写在最后</p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统概述已经更新，传送门：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_59180666/article/details/128982979" title="电子科技大学操作系统期末复习笔记（一）：操作系统概述">电子科技大学操作系统期末复习笔记（一）：操作系统概述</a></p>
<p>本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：</p>
<blockquote>
<ul>
<li><strong>CM1</strong><strong>：</strong> 操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。</li>
<li><strong>CM2</strong><strong>：</strong> 进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。</li>
<li><strong>CM3</strong><strong>：</strong> 内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理和页面置换算法。</li>
<li><strong>CM4</strong><strong>：</strong> 设备管理。I&#x2F;O 系统结构、缓冲管理、磁盘结构和磁盘调度算法。</li>
<li><strong>CM5</strong><strong>：</strong> 文件管理。文件系统的作用、逻辑结构、物理结构、目录、文件共享和文件系统的一致性。</li>
</ul>
</blockquote>
<p>本节要点在CM2，大致内容如下：</p>
<blockquote>
<p><strong>第二章</strong> 进程与并发控制（20 学时，多媒体课件结合板书面授）CM2 </p>
<p>1、主要内容 </p>
<p>程序顺序执行、程序并发执行、进程的定义与特征、进程的基本状态、进程的挂起状态、进 </p>
<p>程控制块、进程的创建、进程的终止、进程的阻塞与唤醒、进程的挂起与激活。临界资源、临界区、利用软件和硬件解决进程互斥问题、整型信号量机制、记录型信号量机制、信号量集机制、生产者－消费者问题、读者和写者问题、哲学家进餐问题、管程机制、进程通信的类型、直接通信和间接通信方式、消息传递系统中的几个问题、消息缓冲队列通信机制。调度的类型、调度队列模型、调度方式和各种调度算法、产生死锁的原因和必要条件、处理死锁的基本方法、死锁的预防和避免、死锁的检测与解除。进程调度算法。满足实时系统要求时，应选择适合实时系统中的调度算法。线程的概念、线程间的同步和通信、用户线程和内核支持线程的概念。 </p>
<p>2、应达到的要求 </p>
<p>记忆：进程的分配方式、管程机制。 </p>
<p>理解：进程的并发执行与控制；实时系统的类型及实时调度算法。线程的概念、线程间的同 </p>
<p>步和通信、用户线程和内核支持线程的概念。 </p>
<p>应用：程序的执行、进程的定义与特征、进程的基本状态、进程控制块、操作系统内核、进 </p>
<p>程的创建、进程的终止、进程的阻塞与唤醒、进程的挂起与激活、线程与进程、进程调度算法。 临界资源、临界区、进程互斥问题、信号量的应用。 </p>
<p>分析：进程调度和死锁、处理死锁的基本方法。进程（线程）的调度算法、生产者&#x2F;消费者 </p>
<p>问题、读者和写者问题、哲学家进餐问题。</p>
</blockquote>
<p>可以看到内容还是很多的，这部分也是重点内容，涉及到7个PPT那就分7个标题吧。</p>
<hr>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><hr>
<h3 id="进程基本知识"><a href="#进程基本知识" class="headerlink" title="进程基本知识"></a>进程基本知识</h3><h4 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h4><blockquote>
<p>程序执行有固定的时序</p>
<p>特征：顺序性、封闭性、可再现性</p>
</blockquote>
<h4 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h4><blockquote>
<ul>
<li>有向无循环图</li>
<li>表示方式： <ul>
<li>p1→p2</li>
<li>→&#x3D;{(p1,p2)| p1 必须在p2开始前完成}</li>
</ul>
</li>
<li>节点表示：一条语句，一个程序段，一个进程</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e94870088ab1.png"></p>
</blockquote>
<h4 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h4><p>特征：间断性、失去封闭性（主要由共享资源引起）、不可再现性（并发程序可能对共享资源做不同的修改）</p>
<p>例子：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/dbfe0f30ceda.png"></p>
<blockquote>
<p>A在B之前，则N分别为 n+1, n+1, 0</p>
<p>A在B之后，则N分别为 n, 0, 1</p>
<p>A在B中间，则N分别为 n, n+1, 0 </p>
</blockquote>
<h4 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h4><p>资源共享：系统中资源被多个程序使用</p>
<p>独立性和制约性：独立的相对速度、起始时间，程序之间相互作用&#x2F;制约</p>
<p>程序与程序的执行不再一一对应</p>
<p>引入并发的目的：提高资源利用率和系统效率</p>
<blockquote>
<p>例子：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/4b547fbd86aa.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/09219604f67a.png"></p>
</blockquote>
<h4 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a><strong>进程的定义和特征</strong></h4><blockquote>
<p>定义：一个具有独立功能的程序在一个数据集合上的一次动态执行的过程。</p>
<p>多进程可以i提高对硬件资源的利用率，但会增加额外的时间空间开销，增加OS的复杂性。</p>
<p>特征：动态性、独立性、并发性、异步性、结构化</p>
<p><strong>进程&#x3D;代码段+数据段+PCB（进程控制块）</strong></p>
<p><strong>一个程序可以对应多个进程（进程：程序&#x3D;n：1）</strong></p>
<p><strong>进程是资源申请和系统调度的基本单位</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>进程</th>
<th>程序</th>
</tr>
</thead>
<tbody><tr>
<td>动态的</td>
<td>静态的</td>
</tr>
<tr>
<td>程序的执行</td>
<td>代码的集合</td>
</tr>
<tr>
<td>暂时的</td>
<td>永久的</td>
</tr>
<tr>
<td>状态变化过程</td>
<td>可以长久保存</td>
</tr>
<tr>
<td>真实地描述并发</td>
<td>不能真实地描述</td>
</tr>
<tr>
<td>可以创建其他进程</td>
<td>不可创建其他程序</td>
</tr>
</tbody></table>
<h4 id="进程的特征和状态"><a href="#进程的特征和状态" class="headerlink" title="进程的特征和状态"></a>进程的特征和状态</h4><p>进程的三种基本状态：就绪、执行、等待&#x2F;阻塞</p>
<p><strong>进程状态图：</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/f91db0c12984.png"></p>
<hr>
<h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h4><p>一些与硬件紧密相关的模块、运行频率较高的模块、共用基本操作模块等<strong>常驻内存的且便于提高操作系统运行效能的软件</strong> ，称为操作系统内核。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a><strong>功能</strong></h4><blockquote>
<ul>
<li><strong>进程管理</strong> ：创建；撤销；调度；控制</li>
<li><strong>存储管理</strong> ：分配&#x2F;回收空间；虚拟存储管理</li>
<li><strong>I&#x2F;O设备管理</strong> ：设备、通道的分配&#x2F;回收；设备的管理；虚拟设备的实现</li>
<li><strong>中断处理</strong> ：操作系统的重要活动都依赖于中断</li>
</ul>
</blockquote>
<hr>
<h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><blockquote>
<ul>
<li>定义：由若干机器指令构成以完成一段特定功能，且在执行过程中不可分割。</li>
<li>原子操作：一个操作中的所有动作，要么全做，要么不做（All-or-None）</li>
</ul>
</blockquote>
<h4 id="原子操作的实现"><a href="#原子操作的实现" class="headerlink" title="原子操作的实现"></a>原子操作的实现</h4><blockquote>
<ul>
<li>单机系统（<strong>屏蔽中断</strong> ） <ul>
<li>单条指令</li>
<li>以屏蔽中断的方式来保证操作的原子性</li>
</ul>
</li>
<li>多核系统（<strong>内存栅障</strong> ） <ul>
<li>一个CPU核执行原子操作时，其他CPU核必须不对指定的内存进行操作，避免<strong>数据竞争</strong> 问题</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="操作系统控制结构"><a href="#操作系统控制结构" class="headerlink" title="操作系统控制结构"></a>操作系统控制结构</h3><blockquote>
<p>操作系统管理计算机资源常用：</p>
<ul>
<li>表格：（或数据结构）记载各资源信息</li>
<li>代码：对资源管理、维护、更新等</li>
</ul>
</blockquote>
<h4 id="进程控制块PCB"><a href="#进程控制块PCB" class="headerlink" title="进程控制块PCB"></a>进程控制块PCB</h4><blockquote>
<p>PCB：Process Control Block，是一个数据结构。</p>
<ul>
<li><strong>是进程存在的唯一标志，且常驻内存</strong></li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/440189917eee.png"></p>
</blockquote>
<blockquote>
<p>PCB的组织方式</p>
<ul>
<li>链接方式 <ul>
<li>把具有同一状态的PCB用其中的链接指针链接成一个队列</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/131d858fb14e.png"></p>
<ul>
<li>索引方式 <ul>
<li>系统根据所有进程的状态建立几张索引表</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/2435f91fedf1.png"></p>
</blockquote>
<h4 id="进程组织（进程树）"><a href="#进程组织（进程树）" class="headerlink" title="进程组织（进程树）"></a>进程组织（进程树）</h4><blockquote>
<p>描述了进程的家族关系</p>
<ul>
<li>子进程可继承父进程的资源</li>
<li><strong>父进程的撤销会撤销全部子进程</strong></li>
<li>根进程：init，launched，pid&#x3D;1</li>
<li><strong>孤儿进程直接托管给根进程</strong></li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/ea4141399655.png"></p>
</blockquote>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>创建场景：用户登录&#x2F;作业调度&#x2F;提供服务&#x2F;应用请求</p>
<p>创建过程：申请空白PCB，分配资源，初始化PCB，插入就绪队列</p>
<h4 id="进程控制函数（fork与exec为主）"><a href="#进程控制函数（fork与exec为主）" class="headerlink" title="进程控制函数（fork与exec为主）"></a>进程控制函数（fork与exec为主）</h4><p><strong>大多数程序中，系统调用的fork和exec是结合在一起使用的：父进程生成一个子进程，再通过调用exec覆盖该子进程。</strong></p>
<blockquote>
<p><strong>fork()：创建新进程</strong></p>
<ul>
<li>调用格式：pid &#x3D; fork()</li>
<li>调用fork后，父子进程均在下一条语句上继续运行</li>
<li>父子进程fork返回值不同 <ul>
<li>失败返回-1</li>
<li>在子进程中返回时，pid为0</li>
<li>在父进程返回时，为其创建的子进程pid</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>fork()：两个关键点</strong></p>
<ul>
<li>运行顺序：父子进程运行无关，运行顺序也不固定。（若要运行顺序一定，需要用到进程间通信）</li>
<li>数据共享：除子进程标识符和PCB特性参数不同外，子进程是父进程的精确复制</li>
</ul>
</blockquote>
<blockquote>
<p>例子：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/c4c22be40734.png"></p>
</blockquote>
<blockquote>
<p><strong>exec()：执行一个文件的调用</strong></p>
<ul>
<li>子进程可以通过exec()调用加载新的程序文件</li>
<li>子进程可以拥有自己的可执行代码，用新进程覆盖调用进程 </li>
<li>调用参数：文件+命令行参数。成功：不返回；失败：返回-1</li>
<li>exec指的是一组函数，一共有6个，分别是</li>
</ul>
<p><code>cpp #include &lt;unistd.h&gt; int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char *const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); </code> </p>
<p>与一般情况不同，exec函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程ID等一些表面上的信息仍保持原样。</p>
<p>只有调用失败了，它们才会返回一个-1，从原程序的调用点接着往下执行。</p>
</blockquote>
<blockquote>
<p>例子:</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/bc422af1a912.png"></p>
</blockquote>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><blockquote>
<p>中止情况：正常结束&#x2F;异常结束&#x2F;外界干预</p>
<ul>
<li>正常结束：exit&#x2F;halt&#x2F;logoff</li>
<li>异常结束：无可用存储器&#x2F;越界&#x2F;保护错误&#x2F;算术错误&#x2F;IO失败&#x2F;无效指令&#x2F;特权指令</li>
<li>外界干预：kill进程&#x2F;父进程中止</li>
</ul>
</blockquote>
<blockquote>
<p>中止过程：</p>
<ul>
<li>检索PCB检查进程状态→执行态改为中止→检查有无子孙需要中止→归还资源给父进程或系统→从PCB队列中移除</li>
<li>系统调用exit(int ret)，返回ret到父进程，释放所有资源，父进程通过wait()等待子进程结束。（wait(pid, status)，ret）</li>
</ul>
</blockquote>
<blockquote>
<p><strong>例子：</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/8230eea6856e.png"></p>
<p><code>cpp Process A: void main(){ printf(&quot;Hello World!&quot;); } Process B: void main(){ if((child=fork())&lt;0){ printf(&quot;Fork Failed!&quot;); } else if(child==0){ if(execv(A)&lt;0){ printf(&quot;Execv Failed!&quot;); } else{ printf(&quot;Bye!&quot;) } } } </code> </p>
</blockquote>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><blockquote>
<ul>
<li>阻塞&#x2F;唤醒，时间片</li>
<li>保存现场&#x2F;恢复现场</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/d18fe0d28bdc.png"></p>
<p>系统调用：会引起从用户态进入核心态</p>
</blockquote>
<hr>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="与进程的区别和联系"><a href="#与进程的区别和联系" class="headerlink" title="与进程的区别和联系"></a>与进程的区别和联系</h4><p>进程：线程&#x3D;1：n</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/739a5ed19208.png"></p>
<h4 id="线程的优势"><a href="#线程的优势" class="headerlink" title="线程的优势"></a>线程的优势</h4><blockquote>
<ul>
<li>减少并发执行时的时空开销（进程的开销较大）</li>
<li>线程是系统独立调度的基本单位<ul>
<li>基本不用有系统资源，只有少量资源，共享其所属进程所拥有的全部资源</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>【回顾】</p>
<p><strong>进程是拥有资源和独立运行的基本单位，线程是系统独立调度的基本单位！！！</strong></p>
</blockquote>
<h4 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h4><blockquote>
<ul>
<li>单线程进程，包括进程控制块和用户地址空间，以及用户栈和内核栈。</li>
<li>多线程环境中，有一个与进程相关联的进程控制块和用户地址空间，每个线程都有一个独立的栈和独立的控制块，包含寄存器值、优先级和其他与线程相关的状态信息。</li>
<li>进程中的所有线程共享该进程的资源，驻留在同一块地址空间中，并且可以访问到相同的数据。</li>
<li>线程阻塞不一定会引起进程阻塞。</li>
</ul>
</blockquote>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><blockquote>
<ul>
<li>执行状态、阻塞状态、就绪状态等 <ul>
<li>阻塞：当线程需要等待一个事件时，它将阻塞，此时处理器执行另一个就绪线程</li>
</ul>
</li>
<li>线程切换时保存的线程信息： <ul>
<li>一个执行栈</li>
<li>每个线程静态存储局部变量</li>
<li>对存储器和其进程资源的访问</li>
</ul>
</li>
<li>派生：产生一个新进程时，同时为其派生一个线程，随后还可以派生另一个线程，新线程被放置在就绪队列中</li>
<li>结束：线程完成时，其寄存器信息和栈都被释放</li>
</ul>
</blockquote>
<h4 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h4><blockquote>
<ul>
<li>内核级线程：每个线程在内核看来都是一个进程</li>
<li>用户级线程：内核无法感知，用户自己控制</li>
</ul>
</blockquote>
<blockquote>
<p>不同点：</p>
<ul>
<li>调度开销 <ul>
<li>内核级线程切换类似于进程切换，开销较大</li>
<li>用户级线程切换在同一用户级进程中，无需进入内核，更快</li>
</ul>
</li>
<li>执行时间 <ul>
<li>用户级线程以进程为单位平均分配时间，对线程间并发不利（单CPU）</li>
<li>内核级线程以线程为单位分配时间（多CPU）</li>
</ul>
</li>
<li>并发效率 <ul>
<li>用户线程：线程阻塞导致进程阻塞（内核不知道线程的存在）</li>
<li>内核线程：线程阻塞，其他进程&#x2F;线程仍可运行</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><blockquote>
<p>分配处理机的任务由进程调度程序完成</p>
<p>处理机是最重要的计算机资源，提高处理机的利用率及改善系统性能（吞吐量、响应时间），在很大程度上取决于进程调度性能的好坏</p>
</blockquote>
<hr>
<h3 id="⭐单处理机调度（重点）"><a href="#⭐单处理机调度（重点）" class="headerlink" title="⭐单处理机调度（重点）"></a>⭐单处理机调度（重点）</h3><h4 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h4><blockquote>
<ul>
<li>面向用户的原则 <ul>
<li>周转时间：作业提交到完成的时间 <ul>
<li>平均周转时间：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://latex.csdn.net/eq?T=%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi=1%7D%5E%7Bn%7DT_%7Bi%7D" alt="T&#x3D;\\frac{1}{n}\\sum_{i&#x3D;1}^{n}T_{i}"></li>
<li>平均带权：<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://latex.csdn.net/eq?T=%5Cfrac%7B1%7D%7Bn%7D%5Csum_%7Bi=1%7D%5E%7Bn%7D%5Cfrac%7BT_%7Bi%7D%7D%7BT_%7Bi,s%7D%7D" alt="T&#x3D;\\frac{1}{n}\\sum_{i&#x3D;1}^{n}\\frac{T_{i}}{T_{i,s}}"> 越接近1越好，越大越差 <ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://latex.csdn.net/eq?T_%7Bi%7D" alt="T_{i}">：周转时间</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://latex.csdn.net/eq?T_%7Bi,s%7D" alt="T_{i,s}">：实际运行时间</li>
</ul>
</li>
</ul>
</li>
<li>响应时间：（交互式作业）提交请求到首次响应的时间</li>
<li>截止时间：开始&#x2F;完成截止时间</li>
<li>优先级：需要抢占&#x2F;剥夺调度</li>
</ul>
</li>
<li>面向系统的原则 <ul>
<li>吞吐量：单位时间完成作业数</li>
<li>利用率</li>
<li>公平性</li>
<li>优先级</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="调度算法：资源分配问题"><a href="#调度算法：资源分配问题" class="headerlink" title="调度算法：资源分配问题"></a>调度算法：资源分配问题</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/17969ea0597b.png"></p>
<blockquote>
<h4 id="先来先服务：FCFS"><a href="#先来先服务：FCFS" class="headerlink" title="先来先服务：FCFS"></a><strong>先来先服务：FCFS</strong></h4><p>简单来说，它就是按顺序执行。</p>
<p>评价</p>
<ul>
<li>非抢占调度</li>
<li>对长进程有利，不利于短进程</li>
<li>适合CPU繁忙型进程，不适合I&#x2F;O繁忙型进程（系统角度）</li>
<li>不能直接用于分时系统</li>
<li>往往与其它调度算法综合使用</li>
</ul>
</blockquote>
<blockquote>
<p><strong>例子：</strong></p>
<table>
<thead>
<tr>
<th><strong>进程名</strong></th>
<th><strong>产生****时刻</strong></th>
<th><strong>服务时间</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>P1</strong></td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td><strong>P2</strong></td>
<td>1</td>
<td>6</td>
</tr>
<tr>
<td><strong>P3</strong></td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td><strong>P4</strong></td>
<td>3</td>
<td>5</td>
</tr>
</tbody></table>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/ad762feef13e.png">**平均 周转时间：((2-0)+(8-1)+(9-2)+(14-3))&#x2F;4 &#x3D; 6.75 **</p>
<p><strong>平均 等待时间：(0+1+6+6)&#x2F;4 &#x3D; 3.25 (注意区分，可能会出审题性错误)</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/feb19e3905ef.png"></p>
</blockquote>
<blockquote>
<h4 id="短作业优先：SPF-SJF"><a href="#短作业优先：SPF-SJF" class="headerlink" title="短作业优先：SPF&#x2F;SJF"></a>短作业优先：SPF&#x2F;SJF</h4><p>执行时间短的先执行</p>
<p>评价</p>
<ul>
<li>有利于短进程，提高了平均周转时间</li>
<li>长进程可能被饿死（starvation）</li>
<li>需要知道或估计每个进程的处理时间。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>例子：</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/c0eb39d2dac7.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/fd0b8ffcf879.png"><strong>平均周转时间：(2+13+1+5)&#x2F;4 &#x3D; 5.25</strong></p>
<p><strong>平均等待时间：(0+7+0+0)&#x2F;4 &#x3D; 1.75</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/1ad26e55b1a2.png"></p>
</blockquote>
<blockquote>
<h4 id="时间片轮转调度：TSRR"><a href="#时间片轮转调度：TSRR" class="headerlink" title="时间片轮转调度：TSRR"></a>时间片轮转调度：TSRR</h4><p>每过固定时间就换下一个进程（按FSCS） </p>
<p>专门为分时系统设计（FCFS的优化）</p>
<ul>
<li>时间片长度变化的影响 <ul>
<li>过长：退化为FCFS，进程在一个时间片内执行完</li>
<li>过短：用户的一次请求需要多个时间片才能处理完，上下文切换次数增加</li>
</ul>
</li>
<li>评价 <ul>
<li>相对公平</li>
<li>偏向于CPU型的进程</li>
<li>中断开销</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>例子：</strong></p>
<p><strong>q指的是时间片长度</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/dc8f33b923ce.png"></p>
<p><strong>平均周转时间：(4+16+12+13+5)&#x2F;5 &#x3D; 10</strong></p>
<p><strong>平均等待时间：(1+10+9+9+5)&#x2F;5 &#x3D; 6.8</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/7c25db44a5e1.png"></p>
<p><strong>平均周转时间：(3+15+7+14+11)&#x2F;5 &#x3D; 10</strong></p>
<p><strong>平均等待时间：(0+9+3+9+9)&#x2F;5 &#x3D; 6</strong></p>
</blockquote>
<blockquote>
<h4 id="最短剩余时间调度：SRT"><a href="#最短剩余时间调度：SRT" class="headerlink" title="最短剩余时间调度：SRT"></a>最短剩余时间调度：SRT</h4><p>对SJF加入剥夺机制：当新进程进入时，可能比当前运行的进程具有更短的剩余时间</p>
<ul>
<li>优点 <ul>
<li>不偏爱长进程，也不像RR产生额外中断，减少了开销。</li>
<li>周转时间方面，比SJF好，短作业可以立即被选择执行。</li>
</ul>
</li>
<li>问题 <ul>
<li>需要知道或估计每个进程所需处理时间；</li>
<li>若持续有短进程存在，长进程可能被饿死；</li>
<li>记录过去的服务时间（以便计算剩余时间）→ 增加了开销。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/3655b6936e3f.png"></p>
</blockquote>
<blockquote>
<h4 id="基于优先权-优先级的调度算法"><a href="#基于优先权-优先级的调度算法" class="headerlink" title="基于优先权&#x2F;优先级的调度算法"></a>基于优先权&#x2F;优先级的调度算法</h4><p>就是先运行优先级高的</p>
<ul>
<li>优先级 <ul>
<li>每个进程设有一个优先级，调度程序选择具有较高优先级的进程。</li>
</ul>
</li>
<li>静态优先级(static) <ul>
<li>优先数在进程创建时分配，生存期内不变。</li>
<li>响应速度慢，开销小。</li>
<li>适合批处理进程</li>
</ul>
</li>
<li>动态优先级(dynamic) <ul>
<li>进程创建时继承优先级，生存期内可以修改。</li>
<li>响应速度快，开销大。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>问题 <ul>
<li>低优先级的进程可能会饿死（无穷阻塞）</li>
</ul>
</li>
<li>改进 <ul>
<li>一个进程的优先级随着它的时间或执行历史而变化——老化策略(aging)。 </li>
<li>执行过程中不断调整其优先级 （如：优先级随执行时间增加而下降，随等待时间增加而升高。）</li>
<li>优点：长短兼顾</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="高响应比优先算法：HRRN"><a href="#高响应比优先算法：HRRN" class="headerlink" title="高响应比优先算法：HRRN"></a>高响应比优先算法：HRRN</h4><p>响应比R &#x3D; 周转时间&#x2F;服务时间 &#x3D; (w+s)&#x2F;s </p>
<p>(w: 等待时间 ；s: 服务时间)</p>
<p>就是先运行响应比高的（<strong>综合考虑等待时间和作业长度</strong> ）</p>
<ul>
<li>评价 <ul>
<li>FCFS和SJF的结合，克服了两种算法的缺点</li>
<li>公平，吞吐率大</li>
<li>需要估计服务时间，增加了计算，增加了开销</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/3187645b87f9.png"></p>
</blockquote>
<blockquote>
<h4 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h4><p>将就绪队列分成多个独立队列，进程所属的队列固定。通过对各队列的区别对待，达到一个综合的调度目标。 </p>
<ul>
<li>策略 <ul>
<li>不同队列可有不同的调度策略 （如前台队列用RR，后台队列用FCFS。）</li>
<li>队列之间的区别：采用固定优先级、可抢占调度来实现 （如前台队列优先级高于后台队列优先级。 ）</li>
<li>只有优先级高的队列中没有进程时，才可以调度优先级低的队列中的进程</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<h4 id="多级反馈队列调度：MFQ"><a href="#多级反馈队列调度：MFQ" class="headerlink" title="多级反馈队列调度：MFQ"></a>多级反馈队列调度：MFQ</h4><p>多级反馈队列算法是多级队列和动态优先级算法的综合和发展。</p>
<p>按时间片、等待时间，使用动态优先级机制；调度基于剥夺原则。</p>
<ul>
<li>策略 <ul>
<li>不同队列可有不同的调度策略 （如前台队列用RR，后台队列用FCFS。）</li>
</ul>
</li>
<li>多个就绪队列，进程所属队列可变，即进程可以在不同的就绪队列之间移动</li>
<li>多个就绪队列分别赋予不同的优先级</li>
<li>队列优先级逐级降低，而时间片长度逐级递增</li>
</ul>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/b28addfca1b6.png"></p>
<p>调度过程</p>
<ol>
<li>新进程进入后，先放入队列0的末尾，按RR顺序调度；</li>
<li>若执行过程中阻塞，则离开队列，被唤醒后，放入同一优先级队列尾部；</li>
<li>若在规定时间片未能执行完，则降低优先级投入队列1的末尾，同样按RR算法调度；如此下去，直到最后的队列； <ol>
<li>若只有1个进程，则不降级；</li>
<li>可有效应对I&#x2F;O繁忙进程。</li>
</ol>
</li>
<li>最后队列按FCFS或者RR（但不再降级）调度直到完成；</li>
<li>若在最后队列等待时间过长，提升优先级；</li>
<li>仅当较高优先级的队列为空，才调度较低优先级的进程执行； <ol>
<li>当前进程一旦开始执行，时间片结束前不被抢占； </li>
<li>若按优先级调度的进程为上一个被抢占的进程，则忽略之，调度下一个候选；</li>
</ol>
</li>
</ol>
</blockquote>
<blockquote>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/c3854d4d5eb9.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/6e3dbf1c7027.png"></p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e6821279a885.png"></p>
<hr>
<h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><h4 id="基本条件"><a href="#基本条件" class="headerlink" title="基本条件"></a>基本条件</h4><ul>
<li>就绪时间：成为就绪状态的时间</li>
<li>开始&#x2F;完成截止时间</li>
<li>处理时间</li>
<li>资源要求</li>
<li>优先级</li>
</ul>
<h4 id="系统处理能力下界"><a href="#系统处理能力下界" class="headerlink" title="系统处理能力下界"></a>系统处理能力下界</h4><p>假定系统中有m个周期性的实时任务，它们的处理时间为Ci，周期为Pi，则在单&#x2F;多处理机情况下，可调度的必要条件：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/582107065c05.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/83d89d9e828c.png"></p>
<h4 id="实时调度算法"><a href="#实时调度算法" class="headerlink" title="实时调度算法"></a>实时调度算法</h4><ul>
<li><p>基于时间片轮转调度 </p>
<ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/95fa64942f0f.png"></li>
</ul>
</li>
<li><p>基于优先级的非抢占调度 </p>
<ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/7fa04490b9b0.png"></li>
</ul>
</li>
<li><p>基于抢占点的抢占调度 </p>
<ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/6f0f0f5ef7fd.png"></li>
</ul>
</li>
<li><p>立即抢占调度 </p>
<ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/f99667890346.png"></li>
</ul>
</li>
<li><p>最早截止时间优先（EDF） </p>
<ul>
<li>可以是抢占式或非抢占式</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/a83c567f9254.png"></li>
</ul>
</li>
<li><p>最低松弛度优先算法（LLF） </p>
<ul>
<li>主要用于可抢占调度方式</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/0746b61faa41.png"></li>
<li>例子：</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/bf723c45348c.png"></li>
</ul>
</li>
<li><p>速度单调调度 </p>
<ul>
<li>任务周期：周期性任务</li>
<li>任务速度：1&#x2F;任务周期</li>
<li>速度越快，优先级越高</li>
</ul>
</li>
</ul>
<hr>
<h3 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><blockquote>
<ul>
<li>紧密耦合 <ul>
<li>共享RAM和I&#x2F;O</li>
<li>高速总线和交叉开关连接</li>
</ul>
</li>
<li>松弛耦合 <ul>
<li>独立RAM和I&#x2F;O</li>
<li>通道和通信线路连接</li>
</ul>
</li>
<li>对称多处理器系统 SMP：Symmetric Multiprocessing</li>
<li>非对称多处理器系统 AMP：Asymmetric Multiprocessing</li>
</ul>
</blockquote>
<h4 id="进程分配方式"><a href="#进程分配方式" class="headerlink" title="进程分配方式"></a>进程分配方式</h4><blockquote>
<ul>
<li>SMP中进程分配方式 <ul>
<li>静态分配</li>
<li>动态分配：可防止系统中多个处理器忙闲不均</li>
</ul>
</li>
<li>非SMP中进程分配方式 <ul>
<li>进程调度在主处理器上执行</li>
<li>有潜在的不可靠性</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="单队列多处理机调度"><a href="#单队列多处理机调度" class="headerlink" title="单队列多处理机调度"></a>单队列多处理机调度</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/c80c03319029.png"></p>
<p>各个处理机自行在就绪队列中取任务（先纵向看，再横向看）。</p>
<p>优点：简单，分布式调度，多个CPU利用率都好</p>
<p>缺点：瓶颈问题（单队列→共享资源→锁） 低效性：cache affinity （下图为改进） </p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/f315ba3c47a9.png"></p>
<h4 id="多队列多处理机调度"><a href="#多队列多处理机调度" class="headerlink" title="多队列多处理机调度"></a>多队列多处理机调度</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/9895315e50ad.png">每个CPU一个队列：没有SQMS的问题，但是可能负载不均衡，导致资源分配不合理。</p>
<h4 id="成组调度"><a href="#成组调度" class="headerlink" title="成组调度"></a>成组调度</h4><blockquote>
<ul>
<li>优点： <ul>
<li>对相互合作的进（线）程组调度，可以减小切换，减小系统开销。</li>
<li>每次分配一组CPU，减少了调度频率。</li>
</ul>
</li>
<li>分配时间 <ul>
<li>面向程序</li>
<li>面向线程：使处理机利用率更高。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="专用处理机分配"><a href="#专用处理机分配" class="headerlink" title="专用处理机分配"></a>专用处理机分配</h4><blockquote>
<ul>
<li>特点：每个进（线）程专用处理机，使其切换小，提高效率。</li>
<li>主要用于大型计算，实时系统 <ul>
<li>Sony PlayStation 3 (PPU&#x2F;SPU) → CELL</li>
<li>神威太湖之光：众核（4+256)</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h2 id="进程并发控制：互斥与同步"><a href="#进程并发控制：互斥与同步" class="headerlink" title="进程并发控制：互斥与同步"></a>进程并发控制：互斥与同步</h2><hr>
<h3 id="进程-线程的并发控制"><a href="#进程-线程的并发控制" class="headerlink" title="进程&#x2F;线程的并发控制"></a>进程&#x2F;线程的并发控制</h3><p>进程&#x2F;线程是计算机中的独立个体：异步性（并发性）</p>
<p>资源是计算机中的稀缺个体：独占性（不可复用性）</p>
<p>进程&#x2F;线程协作完成任务（协作）</p>
<p>并发控制：进程&#x2F;线程在推进时的相互制约关系</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/a8a7222c77c3.png"></p>
<p>并发执行进程能有效地共享资源和相互合作，并按一定顺序执行。</p>
<hr>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<ul>
<li>进程间的制约关系 <ul>
<li>间接制约：资源共享→互斥</li>
<li>直接制约：进程合作→同步</li>
</ul>
</li>
<li>临界资源（Critical Resource） <ul>
<li>一次仅允许一个进程访问的资源</li>
</ul>
</li>
<li>临界区（Critical Section） <ul>
<li>进程中访问临界资源的代码段</li>
</ul>
</li>
<li>忙等、饥饿、死锁 <ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/a7c10cb619dd.png"></li>
</ul>
</li>
<li>活锁 <ul>
<li>两个或多个进程不断更改其状态以响应其他进程的更改而不执行任何有用工作的情况。</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/03d6b070a199.png"></li>
</ul>
</li>
<li>同步原则 <ul>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/5929590ec513.png"></li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="同步的解决策略"><a href="#同步的解决策略" class="headerlink" title="同步的解决策略"></a>同步的解决策略</h3><h4 id="软件方法"><a href="#软件方法" class="headerlink" title="软件方法"></a>软件方法</h4><blockquote>
<p>进程通过执行相应的程序指令，实现与其他进程的互斥与同步</p>
</blockquote>
<h4 id="硬件方法"><a href="#硬件方法" class="headerlink" title="硬件方法"></a>硬件方法</h4><blockquote>
<ul>
<li>屏蔽中断：确保互斥执行 <ul>
<li>缺点： <ul>
<li>系统无法响应外部请求</li>
<li>无法接受异常，处理系统故障</li>
<li>无法切换进程→性能下降</li>
<li>不支持多处理机</li>
</ul>
</li>
</ul>
</li>
<li>机器指令 <ul>
<li>原子性：all-or-nothing</li>
<li>单处理器：一个周期内完成的指令</li>
<li>多处理器：LOCK总线 <ul>
<li>Test &amp; Set <ul>
<li>测试某个变量的值，如果为0，则置1，并返回当前值</li>
</ul>
</li>
<li>Exchange <ul>
<li>原子性地交换寄存器和内存的值</li>
</ul>
</li>
</ul>
</li>
<li>优点： <ul>
<li>支持多处理机</li>
<li>简单易证明</li>
<li>支持多临界区</li>
</ul>
</li>
<li>缺点： <ul>
<li>忙等现象</li>
<li>饥饿现象</li>
<li>死锁现象</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><blockquote>
<ul>
<li>原理： <ul>
<li>多进程通过信号传递协调工作，根据信号指示停止执行（阻塞等待）或者向前推进（唤醒）。</li>
</ul>
</li>
<li>信号：信号量s <ul>
<li>+：资源数量</li>
<li>-：排队数量</li>
</ul>
</li>
<li>原语： <ul>
<li>wait(s)：等待信号，并占有资源 ——&gt;P操作</li>
<li>signal(s)：释放资源，并激发信号 ——&gt;V操作</li>
</ul>
</li>
<li>分类 <ul>
<li>整数型信号量</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/c8902d143515.png"></li>
<li>记录型信号量</li>
<li>AND型信号量 <ul>
<li>将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。 <ul>
<li>只要有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给它</li>
</ul>
</li>
<li>原子操作 <ul>
<li>要么全部分配到进程，要么全不分配</li>
</ul>
</li>
<li>在wait操作中，增加一个AND条件，故称为AND同步，或称为同时wait操作</li>
</ul>
</li>
</ul>
</li>
<li>信号量正负的含义 <ul>
<li>s.value ≥ 0：是可以在不挂起的情况下执行等待的进程数。</li>
<li>s.value &lt; 0：s.value 的大小是 s.queue 中挂起的进程数。</li>
</ul>
</li>
<li>信号量集 <ul>
<li>采用信号量集来控制，可以分配多个资源 <ul>
<li>swait(S1, t1, d1, …, Sn, tn, dn） ti：资源下限； di：需求量</li>
<li><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/3b412e88337e.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><blockquote>
<p>管程的组成</p>
<ul>
<li>局部于该管程的共享数据，这些数据表示了相应资源的状态；</li>
<li>针对上述数据的一组过程；</li>
<li>对局部于该管程的数据的初始化。</li>
</ul>
</blockquote>
<blockquote>
<p>管程的特点</p>
<ul>
<li>模块化（Modularization） <ul>
<li>管程是一个基本程序单位，可以单独编译;</li>
</ul>
</li>
<li>抽象数据类型（Abstraction) <ul>
<li>管程中不仅有数据，而且有对数据的操作;</li>
</ul>
</li>
<li>信息隐藏（Encapsulation） <ul>
<li>管程外可以调用管程内部定义的函数，但函数具体实现外部不可见;</li>
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问。</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>管程的同步</p>
<ul>
<li>进程通过调用管程的一个过程进入管程；</li>
<li>在任何时候，只能有一个进程在管程中执行；调用管程的任何其他进程都被挂起，以等待管程变成可用。</li>
<li>条件变量提供同步支持（非默认锁）。条件变量包含在管程中，并且只有在管程中才能被访问： <ul>
<li>cwait(x)：调用进程的执行在条件x上挂起，管程现在可被另一进程使用。</li>
<li>csignal(x)：恢复阻塞在x上的进程。</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h2 id="⭐进程并发控制：信号量的应用（重点）"><a href="#⭐进程并发控制：信号量的应用（重点）" class="headerlink" title="⭐进程并发控制：信号量的应用（重点）"></a>⭐进程并发控制：信号量的应用（重点）</h2><p>展示一些信号量实例，也是重点考察的地方</p>
<hr>
<h3 id="观察者问题"><a href="#观察者问题" class="headerlink" title="观察者问题"></a>观察者问题</h3><blockquote>
<p>观察者和报告者是两个并发执行的进程。 观察者不断观察并对通过的卡车计数； 报告者不停地将观察者的计数打印，并归零。 请用P、V原语进行正确描述。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/c796a0df5616.png"></p>
</blockquote>
<hr>
<h3 id="图书馆问题"><a href="#图书馆问题" class="headerlink" title="图书馆问题"></a>图书馆问题</h3><blockquote>
<p>图书馆有N个座位，一张登记表，要求： 读者进入时需先登记，取得座位号； 出来时注销 用P、V原语描述读者的使用过程。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/61b9bc2b9f7d.png"></p>
</blockquote>
<hr>
<h3 id="公交车问题"><a href="#公交车问题" class="headerlink" title="公交车问题"></a>公交车问题</h3><blockquote>
<p>司机启动车辆的动作必须于售票员关车门的动作取得同步；售票员开车门的动作也必须与司机停车取得同步。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/faa00c5d86ac.png"></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/0d43c88cf1dd.png"></p>
</blockquote>
<hr>
<h3 id="⭐生产者-消费者问题（重点）"><a href="#⭐生产者-消费者问题（重点）" class="headerlink" title="⭐生产者&#x2F;消费者问题（重点）"></a>⭐生产者&#x2F;消费者问题（重点）</h3><blockquote>
<p>生产者&#x2F;消费者模型：</p>
<p>生产者：满则等待，空则填充</p>
<p>消费者：空则等待，有则获取</p>
<p>不允许同时进入缓冲区</p>
<p>无限缓冲：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/6545385448c6.png"></p>
<p>有限循环&#x2F;环形缓冲区：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/2a7232ba32c4.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/f8e8c9b4c0bf.png"></p>
</blockquote>
<h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><blockquote>
<p>有3个进程PA，PB和PC合作解决文件打印问题：</p>
<p>PA将文件记录从磁盘读入主存的缓冲区1，每执行一次读一个记录;</p>
<p>PB将缓冲区1的内容复制到缓冲区2，每执行一次复制一个记录；</p>
<p>PC将缓冲区2的内容打印出来，每执行一次打印一个记录。</p>
<p>缓冲区的大小等于一个记录大小。</p>
<p>请用P，V操作来保证文件的正确打印。 </p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/83a983b86f84.png"></p>
<p>信号量：empty1，empty2：分别表示缓冲区1及缓冲区2是否为空，初值为1。</p>
<p>full1，full2：分别表示缓冲区1及缓冲区2是否有记录可供处理，初值为0。</p>
<p>mutex1，mutex2：分别表示缓冲区1及缓冲区2的访问控制，初值为1。 </p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/0499d2677fe4.png"></p>
</blockquote>
<h4 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h4><blockquote>
<ul>
<li>资源数量：资源信号量</li>
<li>资源访问：互斥信号量</li>
<li>先申请资源，再申请访问权</li>
<li>资源信号量P、V操作分布在不同进程</li>
<li>互斥信号量P、V操作出现在同一进程</li>
</ul>
</blockquote>
<hr>
<h3 id="⭐读-写者问题（重点）"><a href="#⭐读-写者问题（重点）" class="headerlink" title="⭐读&#x2F;写者问题（重点）"></a>⭐读&#x2F;写者问题（重点）</h3><blockquote>
<p>三个角色：一个共享的数据区； Reader: 只读取这个数据区的进程； Writer: 只往数据区中写数据的进程；</p>
<p>三个条件：多个Reader可同时读数据区； 一次只有一个Writer可以往数据区写； 数据区不允许同时读写。（“读－写” 互斥；“写－写” 互斥；“读－读” 允许）</p>
</blockquote>
<h4 id="读者优先"><a href="#读者优先" class="headerlink" title="读者优先"></a>读者优先</h4><p>一旦有读者正在读数据，则允许随后的读者进入读数据；只有当全部读者退出，才允许写者进入写数据；导致<strong>写者饥饿</strong></p>
<p><strong>信号量设置：</strong></p>
<p>wsem：互斥信号量，用于Writers间互斥，Writers和Readers互斥</p>
<p>readcount：统计同时读数据的Readers个数</p>
<p>mutex：对变量readcount互斥算术操作</p>
<p><code>cpp int readcount=0； semaphore mutex = 1, wsem=1; void reader() { while (1) { P(mutex); readcount++; if (readcount==1) P(wsem); V(mutex); READ; P(mutex); readcount--; if (readcount==0) V(wsem); V(mutex); } } void writer() { while (1) { P(wsem); WRITE; V(wsem); } } </code> </p>
<h4 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先"></a>写者优先</h4><p>当至少有一个写者声明想写数据时，则不再允许新的读者进入读数据。例如：队列：（尾)WWRRW(头)，让三个W进程能优先于R进程写数据。解决了写者饥饿问题，但<strong>降低了并发程度，系统的并发性能较差</strong> 。</p>
<p><strong>信号量设置:</strong></p>
<p>wsem：互斥信号量，用于Writers间互斥，Reader互斥Writers</p>
<p>rsem：互斥信号量，当至少有一个写者申请写数据时互斥新的读者进入读数据。第一个写者受rsem影响，一旦有第一个写者，后续写者不受rsem其影响。但是读者需要在rsem上排队。</p>
<p>mwc：用于控制writecount互斥算术操作</p>
<p>mrc：用于控制readcount互斥算术操作</p>
<p>z: 对读者进行控制，防止在rsem上出现读进程的长队列，否则写进程不能跳过这个队列</p>
<p><code>cpp int readcount, writecount; semaphore mrc=l, mwc=1, z=1, wsem=1, rsem=l; void reader( ) { while (1) { P(z); P(rsem); P(mrc); readcount++; if (readcount == 1) P(wsem); V(mrc); V(rsem)； V(z); READ; P(mrc); readcount--; if (readcount == 0) V(wsem); V(mrc); } } void writer( ) { while (1) { P(mwc); writecount++; if (writecount == 1) P(rsem); V(mwc); P(wsem); WRITE; V(wsem); P(mwc); writecount--; if (writecount == 0) V(rsem); V(mwc); } } </code> </p>
<h4 id="公平优先"><a href="#公平优先" class="headerlink" title="公平优先"></a>公平优先</h4><p><strong>写过程中，若其它读者、写者到来，则按****到达顺序处理</strong></p>
<p><strong>信号量设置：</strong></p>
<p>w：互斥信号量，用于Writers间互斥，Reader互斥Writers</p>
<p>readcount：统计同时读数据的Readers个数</p>
<p>mrc：对变量readcount互斥算术操作</p>
<p>r：互斥信号量，确定Writer 、Reader请求顺序</p>
<p>在读者优先中，wsem只对第一个读者起阻塞作用，后续读者不受其影响。为了保证按照到达顺序处理，故公平优先方式设置wrsem,读者／写者按到达顺序在wrsem上排队。</p>
<p><code>cpp int readcount = 0; semaphore mrc = 1, r = 1, w = 1; READER { P(r); P(mrc); readcount++; if (readcount == 1) P(w); V(mrc); V(r); Read(); P(mrc); readcount--; if (readcount == 0) V(w); V(mrc); } WRITER { P(r); P(w); Write(); V(w); V(r); } </code> </p>
<hr>
<h3 id="⭐理发师问题（重点）"><a href="#⭐理发师问题（重点）" class="headerlink" title="⭐理发师问题（重点）"></a>⭐理发师问题（重点）</h3><blockquote>
<p>角色和资源：一个理发师 一个理发椅 一排座位 随机到来的客户</p>
<p>场景：理发师：有客干活，无客睡觉；客户：唤醒理发师，有位等待，无位离开</p>
<p>此问题无死锁，有饥饿（以排队方式解决饥饿问题）</p>
</blockquote>
<p><code>cpp /* # of customers waiting */ semaphore customers = 0; /* barber status */ semaphore barbers = 0; /* mutual exclusion to access seats */ semaphore mutex = 1; /* # of available seats. */ int nas = N; void barber(void) { while (TRUE) { P(customers); P(mutex); nas++; V(barbers); V(mutex); cut_hair(); } } void customer(void) { P(mutex); if (nas &gt; 0) { nas--; V(customers); V(mutex); P(barbers); get_haircut(); } else { V(mutex); leave_shop(); } } </code> </p>
<hr>
<h3 id="⭐哲学家问题（重点）"><a href="#⭐哲学家问题（重点）" class="headerlink" title="⭐哲学家问题（重点）"></a>⭐哲学家问题（重点）</h3><blockquote>
<p>哲学家就餐问题可以用来解释死锁和资源耗尽。</p>
<p>描述：5个哲学家围坐一张餐桌；5只餐叉（筷子）间隔摆放；思考或进餐；进餐时必须同时拿到两边的餐叉；思考时将餐叉放回原处。</p>
</blockquote>
<p><code>cpp #define N 5 #define LEFT (i-1+N)%N #define RIGHT (i+1)%N #define THINKING 0 #define HUNGRY 1 #define EATING 2 int state[N] = {0, 0, 0, 0, 0}; semaphore mutex = 1; semaphore s[N]={0,0,0,0,0}; void philosopher(int i){ while (TRUE) { think(); take_forks(i); eat(); put_forks(i); } } void take_forks(int i) { P(mutex); state[i] = HUNGRY; test(i); V(mutex); P(s[i]); } void put_forks(i) { P(mutex); state[i] = THINKING; test(LEFT); test(RIGHT); V(mutex); } void test(int i) { if (state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] != EATING) { state[i] = EATING; V(s[i]); } } </code> </p>
<hr>
<h3 id="重点知识点回顾"><a href="#重点知识点回顾" class="headerlink" title="重点知识点回顾"></a>重点知识点回顾</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/313310aba8d2.png"></p>
<hr>
<h2 id="进程并发控制：练习题"><a href="#进程并发控制：练习题" class="headerlink" title="进程并发控制：练习题"></a>进程并发控制：练习题</h2><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><blockquote>
<p>桌子上有一只盘子，最多可以放入N（N&gt;0）个水果</p>
<p>爸爸随机向盘中放入苹果或桔子； 儿子只吃盘中的桔子； 女儿只吃盘中的苹果； 只有盘子中水果数目小于N时，爸爸才可以向盘子中放水果； 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果； 每次只能放入或取出一个水果，不允许多人同时使用盘子。</p>
<p>用P、V操作实现爸爸、儿子和女儿之间的同步与互斥活动。</p>
<p><code>cpp semaphore mutex = 1; //盘子操作互斥信号量 semaphore apple = 0, orange = 0; //苹果、桔子放入、取出的资源信号量 semaphore empty = N; //盘子中可放入的水果数目 dad() { while (true) { result= prepare _fruit(); //准备水果，result为水果类型 P(empty); //盘子中可放入的水果数目减1 P(mutex); //互斥访问盘子 put a fruit on the plate; //将一个水果放入盘子 V(mutex); //恢复访问盘子 if (result == fruit_apple) //准备的水果为苹果 V(apple); //允许女儿取苹果 else //准备的水果为桔子 V(orange); //允许儿子取桔子 } } son() { while (true) { P(orange); //互斥取桔子 P(mutex); //互斥访问盘子 get an orage from plate(); //取桔子 V(mutex); //恢复访问盘子 V(empty); //盘子中可放入的水果数目加1 } } daughter() { while (true) { P(apple); //互斥取水果 P(mutex); //互斥访问盘子 get an apple from plate(); //取苹果 V(mutex); //恢复访问盘子 V(empty); //盘子中可放入的水果数目加1 } } </code> </p>
</blockquote>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><blockquote>
<p>桌子上有一只盘子，只能放一只水果</p>
<p>爸爸负责向盘中放苹果，妈妈负责向盘中放桔子。 儿子只吃盘中的桔子，女儿只吃盘中的苹果。 只有盘子为空时，爸爸或妈妈才可以向盘子中放入一个水果。 仅当盘子中有自己需要的水果时，儿子或女儿才可以从盘子中取出相应的水果。 同一时刻只能有一个人操作盘子</p>
<p>请用信号量机制实现爸爸、妈妈、儿子和女儿之间的同步与互斥活动。</p>
<p><code>cpp semaphore plate = 1; //盘子是否有空间 semaphore mutex = 1; semaphore apple = 0, orange = 0; //盘子中是否有苹果、桔子 dad() { while (true) { prepare an apple; P(plate); P(mutex) put the apple on the plate; V(mutex) V(apple); } } mom() { while (true) { prepare an orange; P(plate); P(mutex); put the orange on the plate; V(mutex) V(orange); } } son() { while (true) { P(orange); P(mutex); get an orange; V(mutex); V(plate); } } daughter() { while (true) { P(apple); P(mutex); get an apple; V(mutex); V(plate); } } </code> </p>
<p>因为缓冲区大小就为1，所以可以省略mutex信号量。</p>
</blockquote>
<h4 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h4><blockquote>
<p>桌子上有一只盘子 最多可以放入2个水果。</p>
<p>爸爸负责向盘中放苹果，妈妈负责向盘中放桔子，女儿负责取出并消费水果。 当且仅当盘子中同时存在苹果和桔子时，女儿才从盘子中取出并消费水果。 不允多人同时使用盘子</p>
<p>请用信号量机制实现爸爸、妈妈和女儿之间的同步与互斥活动。</p>
<p><code>cpp semaphore apple = 0, orange = 0; //盘子中是否有苹果、桔子 semaphore empty_apple = 1, empty_orange = 1; //盘子是否可放入苹果、桔子 semaphore mutex = 1; dad(){ while (true) { prepare an apple; P(empty_apple); P(mutex); put an apple on the plate; V(mutex); V(apple); } } mom(){ while (true) { prepare an orange; P(empty_orange); P(mutex); put an orange on the plate; V(mutex); V(orange); } } daughter() { while (true) { P(apple); P(orange); P(mutex); get an apple and an orange from plate; //取水果 V(mutex); V(empty_apple); V(empty_orange); } } </code> </p>
<p>这里的mutex不可以省略，缓冲区的大小不为1，资源信号量无法兼顾互斥信号量的工作。</p>
</blockquote>
<h4 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h4><blockquote>
<p>女儿画画，爸爸、妈妈欣赏。</p>
<p>女儿在白板上画完一幅画后，请爸爸、妈妈均欣赏过一遍后，再创作新画。</p>
<p>请用信号量机制实现女儿、爸爸和妈妈之间的同步与互斥活动。</p>
<p><code>cpp //爸爸、妈妈是否已看过女画的新画 semaphore empty_dad = 1, empty_mom = 1; //是否存在可供爸爸、妈妈看的新画 semaphore full_dad = 0, full_mom = 0; daughter(){ while (true) { P(empty_dad); //爸爸是否看过 P(empty_mom); //妈妈是否看过 draw a new picture on the whiteboard; //画一幅新画 V(full_dad); //爸爸可以看了 V(full_mom); //妈妈可以看了 } } dad() { while (true) { P(full_dad); //白板上是否存在没有看过的画 enjoy the picture on the whiteboard; //看画 V(empty_dad); //爸爸已看过新画 } } mom() { while (true) { P(full_mom); //白板上是否存在没有看过的画 enjoy the picture on the whiteboard; //看画 V(empty_mom); //妈妈已看过新画 } } </code> </p>
</blockquote>
<h4 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h4><blockquote>
<p>有一座东西方向的独木桥，每次只能有一人通过，且不允许行人在桥上停留。东、西两端各有若干行人在等待过桥。请用P、V操作来实现东西两端行人过桥问题。</p>
<p><code>cpp semaphore mutex = 1; //互斥信号量 void east_west( ) { while (true) { P(mutex); //互斥其他人过桥 walk across the bridge from east to west;//行人从东向西过桥 V(mutex); //允许其他人过桥 } } void west_east( ) { while (true) { P(mutex); //互斥其他人过桥 walk across the bridge from west to east;//行人从西向东过桥 V(mutex); //允许其他人过桥 } } </code> </p>
</blockquote>
<h4 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h4><blockquote>
<p>有一座东西方向的独木桥</p>
<p>同一方向的行人可连续过桥。当某一方向有行人过桥时，另一方向行人必须等待，直到对方全部通过。 桥上没有行人过桥时，任何一端的行人均可上桥。</p>
<p>请用P、V操作来实现东西两端人过桥问题。 </p>
<p><code>cpp int countA=0, countB=0； semaphore mutex=1, muteA=1, mutexB=1; void east_west() { while (1) { P(mutexA); countA++; if (countA==1) P(mutex); V(mutexA); walk across the bridge from east to west; P(mutexA); countA--; if (countA==0) V(mutex); V(mutexA); } } void west_east() { while (1) { P(mutexB); countB++; if (countB==1) P(mutex); V(mutexB); walk across the bridge from west to east; P(mutexB); countB--; if (countB==0) V(mutex); V(mutexB); } } </code> </p>
</blockquote>
<h4 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h4><blockquote>
<p>有一座东西方向的独木桥， 同一方向的行人可连续过桥。</p>
<p>当某一方向有行人过桥时，另一方向行人必须等待。 桥上没有行人时，任何一端的行人均可上桥。 出于安全考虑，独木桥的最大承重为4人，即同时位于桥上的行人数目不能超过4。</p>
<p>请用P、V操作来实现东西两端人过桥问题。 </p>
<p><code>cpp int countA=0, countB=0； semaphore mutex=1, muteA=1, mutexB=1,count=4; void east_west() { while (1) { P(mutexA); countA++; if (countA==1) P(mutex); V(mutexA); P(count); walk across the bridge from east to west; V(count); P(mutexA); countA--; if (countA==0) V(mutex); V(mutexA); } } void west_east() { while (1) { P(mutexB); countB++; if (countB==1) P(mutex); V(mutexB); P(count); walk across the bridge from west to east; V(count); P(mutexB); countB--; if (countB==0) V(mutex); V(mutexB); } } </code> </p>
</blockquote>
<h4 id="问题8"><a href="#问题8" class="headerlink" title="问题8"></a>问题8</h4><blockquote>
<p>某寺庙有小和尚和老和尚各若干人，水缸一只，由小和尚提水入缸给老和尚饮用。水缸可容水m桶，水取自同一口水井中。水井径窄，每次仅能容一只水桶取水，水桶总数为n个。若每次提水、取水仅为1桶，试用P, V操作描述小和尚和老和尚提水、取水的活动过程</p>
<p><code>cpp semaphore mutex1=1, mutex2=1; semaphore empty=m, full=0; semaphore count=n; process 小和尚(i) (i=1，2，…) begin repeat P(empty); //水缸满否? P(count); //取得水桶 P(mutex1); //互斥从井中取水 从井中取水; V(mutex1); P(mutex2); //互斥使用水缸 倒水入缸; V(mutex2); V(count); //归还水桶 V(full); //多了一桶水 until false; end process 老和尚(取水)j(j=1，2，…) begin repeat P(full); //有水吗? P(count); //申请水桶 P(mutex2); //互斥取水 从缸中取水; V(mutex2); V(count); //归还水桶 V(empty); //水缸中少了一桶水 until false; end </code> </p>
</blockquote>
<h4 id="问题9"><a href="#问题9" class="headerlink" title="问题9"></a>问题9</h4><blockquote>
<p>N个生产者进程和M个消费者进程共享大小为K的缓冲区，遵循规则如下： 进程之间必须以互斥方式访问缓冲区； 对每1条放入缓冲区的数据，所有消费者都必须接收1次； 缓冲区满时，生产者必须阻塞； 缓冲区空时，消费者必须阻塞。 请用P、V操作实现其同步过程，须说明信号量含义。</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/45fe74fd6f8b.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/4e85f3c406c8.png"></p>
</blockquote>
<hr>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><blockquote>
<p>Inter Process Communication: IPC 是指进程之间的信息交换</p>
</blockquote>
<hr>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>进程通信分为两类：</p>
<ul>
<li>低级通信：以信号量作为通信工具，交换的信息量少。</li>
<li>高级通信：操作系统所提供的一组通信命令，高效地传送大量数据。 <ul>
<li>共享存储（Shared Memory）</li>
<li>消息传递&#x2F;消息队列（Message Passing&#x2F;Message Queue）</li>
<li>管道（Pipe）</li>
<li>套接字（Socket）</li>
<li>文件（File）</li>
<li>信号（Signal）</li>
<li>内存映射文件（Memory Mapped File）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>共享存储：</p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/82a798fff3c7.png"></p>
</blockquote>
<hr>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><blockquote>
<ul>
<li>数据交换以格式化的消息为单位；直接利用系统提供的一组通信命令（原语）进行通信。 <ul>
<li>间接通信方式 （Indirect Communication） <ul>
<li>中介：信箱。</li>
<li>发送进程发送给目标进程的消息存放信箱； 接收进程则从该信箱中，取出发送给自己的消息；</li>
<li>消息在信箱中安全地保存，只允许核准的用户读取。</li>
<li>系统为信箱通信提供了若干条原语，分别用于信箱的创建、撤消和消息的发送、接收等。</li>
</ul>
</li>
<li>直接通信方式（Direct Communication） <ul>
<li>直接把消息发送给目标进程。</li>
</ul>
</li>
</ul>
</li>
<li>跨节点的进程间通信 <ul>
<li>套接字（socket）</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="管道（Pipe）通信"><a href="#管道（Pipe）通信" class="headerlink" title="管道（Pipe）通信"></a>管道（Pipe）通信</h3><p>用于连接一个读进程和一个写进程以实现他们之间通信的共享文件，又名pipe文件。</p>
<ul>
<li>无名管道（unnamed pipe） <ul>
<li>$ ls | grep x</li>
</ul>
</li>
<li>命名管道（named pipe） <ul>
<li>$ mkfifo mypipe</li>
</ul>
</li>
</ul>
<hr>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><blockquote>
<p>多个进程在运行过程中因争夺资源而造成的一种僵局（Deadly- Embrace），当进程处于这种僵持状态时，若无外力作用，它们都将无法向前推进。</p>
</blockquote>
<hr>
<h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><blockquote>
<ul>
<li>资源不足导致的资源竞争：多个进程所共享的资源不足，引起它们对资源的竞争而产生死锁。</li>
<li>并发执行的顺序不当：进程运行过程中，请求和释放资源的顺序不当，而导致进程死锁。</li>
</ul>
</blockquote>
<hr>
<h3 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h3><blockquote>
<ul>
<li>资源（R1, R2, . . ., Rm） <ul>
<li>CPU, memory, I&#x2F;O devices</li>
</ul>
</li>
<li>资源Ri拥有的实例数 Wi（instance）</li>
<li>进程使用资源的方式 <ul>
<li>请求（request）</li>
<li>占用&#x2F;使用（use）</li>
<li>释放（release）</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="资源类型"><a href="#资源类型" class="headerlink" title="资源类型"></a>资源类型</h3><blockquote>
<ul>
<li>重用型资源（Reusable Resource） <ul>
<li>一次只能供一个进程使用，不会由于使用而耗尽</li>
<li>例: CPU、 I&#x2F;O通道、主存和辅存、 设备、文件、数据库、信号量等数据结构</li>
</ul>
</li>
<li>消费型资源（Consumable Resource） <ul>
<li>可以创建并且可以销毁的资源 数目没有限制，当一个进程得到一个可消费资源后，这个资源就不再存在了</li>
<li>例: 中断、信号、 消息、 I&#x2F;O缓冲区中的信息</li>
</ul>
</li>
</ul>
</blockquote>
<hr>
<h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><blockquote>
<p>RAG: Resource-Allocation Graph</p>
<p>进程：P &#x3D; {P1, P2, …, Pn}</p>
<p>资源：R &#x3D; {R1, R2, …, Rm}</p>
<p>资源请求边（request）： Pi → Rj</p>
<p>资源分配边（assignment ）：Rj → Pi </p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/8f21565d71ac.png"></p>
</blockquote>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/04fdf8afd156.png"> 实例  <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/1e7c9624e405.png"> 死锁 </p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/ae7a7ab11171.png"> 带环但无死锁 </p>
<hr>
<h3 id="死锁的充要条件"><a href="#死锁的充要条件" class="headerlink" title="死锁的充要条件"></a>死锁的充要条件</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/2666d652b870.png"></p>
<blockquote>
<p><strong>互斥条件</strong></p>
<p>进程对所分配到的资源进行排它性使用。如果此时还有其它进程申请该资源，则只能阻塞，直至占有该资源的进程释放。</p>
<p><strong>占有且等待（请求和保持条件）</strong></p>
<p>进程已经占有了至少一个资源，又提出了新的资源要求，而该资源已被其它进程占有，此时请求进程阻塞，且对已经获得的其它资源保持不放。 </p>
<p><strong>非抢占（非剥夺）条件</strong></p>
<p>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p>
<p><strong>循环等待条件</strong></p>
<p>在发生死锁时，存在一个进程—资源的封闭的环形链。</p>
<p>以上四条缺一不可。</p>
</blockquote>
<hr>
<h3 id="处理死锁的基本方法"><a href="#处理死锁的基本方法" class="headerlink" title="处理死锁的基本方法"></a>处理死锁的基本方法</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/8d2635cc4a9c.png"></p>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><blockquote>
<p>通过限制申请资源的方法来破坏产生死锁的条件（四个方面）</p>
<p><strong>互斥条件</strong></p>
<p>由资源的固有特性所决定，不能被破坏。</p>
<p><strong>打破“占有和等待”</strong></p>
<p>进程开始运行前一次性地申请全部资源，启动后不再申请。</p>
<p>优点: 简单、易于实现、安全</p>
<p>缺点: 无法预知所需资源的全集；进程可能被阻塞很长时间，等待资源，发生饥饿；资源严重浪费（某个资源可能只用极短时间）</p>
<p><strong>打破“非抢占”</strong></p>
<p>资源拥有者拒绝其它请求后释放资源，或从被申请资源拥有者处抢占</p>
<p>适用条件：资源的状态可保存和恢复，如CPU寄存器、内存空间；不适用于打印机、磁带机</p>
<p>缺点：实现复杂，代价大，反复申请&#x2F;释放资源，周转时间长，系统吞吐量低；undo、redo</p>
<p><strong>打破“环路等待”</strong></p>
<p>系统把所有资源按类型进行线性排队；所有进程对资源的请求必须严格按资源序号递增的顺序提出，保证任何时刻的资源分配图不出现环路。即：如果一个进程已经分配了R类型的资源，它接下来请求的资源只能是排在R类型之后的资源。</p>
<p>摒弃“环路等待” 方法的问题：资源变化：资源序号要稳定； 资源浪费： 只用第一个和最后一个资源； 使用顺序和申请顺序不一致； 程序设计：考虑申请顺序，编写困难</p>
</blockquote>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><blockquote>
<p>不需事先破坏产生死锁的条件</p>
<p>在系统运行过程中，对进程发出的每一个资源申请进行检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配（阻塞），否则予以分配。</p>
<p>防止系统进入<strong>不安全状态</strong> , 从而避免发生死锁。</p>
<p><strong>安全状态：</strong> 存在安全序列的系统状态</p>
<p><strong>安全序列</strong> ：一个进程序列{P1，…，Pn}是安全的：如果对于每一个进程Pi(1≤i≤n），它尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。</p>
<p><strong>安全状态时一定没有死锁</strong> （当前状态非死锁，<strong>并不保证未来</strong> ）</p>
<p><strong>死锁一定是不安全状态</strong> ，但不安全状态下不一定会死锁</p>
<p>总结</p>
<ul>
<li>优点 <ul>
<li>比死锁预防限制少</li>
<li>无死锁检测方法中的资源剥夺，进程重启</li>
</ul>
</li>
<li>缺点 <ul>
<li>必须事先声明每个进程请求的最大资源</li>
<li>进程必须是无关的：没有任何同步要求的限制</li>
<li>进程数量保持不变，分配的资源数目必须是固定的</li>
<li>在占有资源时，进程不能退出</li>
<li>保守的分配方案（设置条件严格）</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>银行家算法</strong></p>
<blockquote>
<p>当用户申请资源时，系统判断如果把这些资源分出去，系统是否还处于安全状态。</p>
<p>若是，就可以分配这些资源； 否则，暂时不分配，阻塞进程。 </p>
</blockquote>
<p><strong>安全性算法</strong></p>
<blockquote>
<ol>
<li>设Work和Finish分别是长度为m和n的向量，按如下方式进行初始化:</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>Work &#x3D; Available</li>
<li>Finish[i] &#x3D; false for i &#x3D; 1,2, …, n.</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li>查找这样的i使其满足:</li>
</ol>
</blockquote>
<blockquote>
<ul>
<li>Finish[i] &#x3D; false</li>
<li>Need[i] &lt;&#x3D; Work</li>
<li>如果未找到，转第4步.</li>
</ul>
</blockquote>
<blockquote>
<ol>
<li>Work &#x3D; Work + Allocation[i]; Finish[i] &#x3D; True；返回第2步</li>
<li>如果对所有的i, Finish[i]&#x3D;&#x3D;True，那么处于安全状态，否则不安全状态。</li>
</ol>
</blockquote>
<p><strong>资源分配算法</strong></p>
<blockquote>
<ul>
<li>Requesti为进程Pi的请求向量。如果Requesti [j] &#x3D; k 那么进程Pi 所需要的资源类型Rj的实例数量为k。当进程Pi做出资源请求时，执行： <ul>
<li>若Requesti &lt;&#x3D;Needi 转1.2；否则，出错退出；</li>
<li>若Requesti &lt;&#x3D;Available 转2； 否则 Pi阻塞；</li>
</ul>
</li>
<li>假定系统可以分配给进程Pi所请求的资源，并按如下方式修改状态: <ul>
<li>Available &#x3D; Available - Requesti;</li>
<li>Allocationi &#x3D; Allocationi + Requesti;</li>
<li>Needi &#x3D; Needi – Requesti;</li>
</ul>
</li>
<li>系统执行安全性算法 <ul>
<li>如果处于安全状态，那么Pi可分配到其所需资源;</li>
<li>如果新状态不安全，那么进程Pi必须等待，并恢复到原先资源分配状态</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>实例</strong></p>
<p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/22ee0204fc78.png"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/b24aceee09e8.png"></p>
<h4 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h4><p>如果一个系统既不采用死锁预防算法也不采用死锁避免算法，那么可能会出现死锁。因此，系统应该提供：用来检查系统状态是否出现死锁的检测算法、从死锁状态中恢复的方法。</p>
<blockquote>
<ul>
<li>死锁检测 <ul>
<li>没有任何预先限制措施</li>
<li>资源分配时不检查系统是否会进入不安全状态，被请求的资源都被授予给进程</li>
<li>系统可能出现死锁</li>
<li>周期性检测是否出现死锁（执行检测算法）</li>
</ul>
</li>
<li>检测时机 <ul>
<li>在每个资源请求时都进行</li>
<li>定时检测</li>
<li>系统资源利用率下降时检测死锁</li>
</ul>
</li>
<li>简化资源分配图 <ul>
<li>简化规则：若已分配和申请能满足需求，则删除边，使其成为孤立点→运行完毕后资源释放；</li>
<li>在经过一系列的简化后，若能消去图中的所有边，使所有的进程都成为孤立结点，则称该图是可完全简化的；反之的是不可完全简化的。</li>
<li>死锁定理：<strong>死锁状态的充要条件：资源分配图不可完全简化</strong></li>
</ul>
</li>
<li>死锁定理与不安全状态的关系 <ul>
<li>死锁定理：当前请求（request） </li>
<li>不安全状态：所有剩余请求（need）</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h4><blockquote>
<ul>
<li>撤销进程 <ul>
<li>终止所有的死锁进程</li>
<li>一次终止一个进程直到取消死锁循环→基于某种最小代价原则</li>
</ul>
</li>
<li>选择原则 <ul>
<li>已消耗CPU时间最少</li>
<li>到目前为止产生的输出量最少</li>
<li>预计剩余的时间最长</li>
<li>目前为止分配的资源总量最少</li>
<li>优先级最低</li>
</ul>
</li>
<li>资源剥夺：逐步从进程中抢占资源给其它进程，直到死锁环被打破为止 。 <ul>
<li>选择一个牺牲品：抢占哪些资源和哪个进程，确定抢占顺序以使代价最小。</li>
<li>饥饿：确保资源不会总是从同一个进程中被抢占</li>
</ul>
</li>
<li>进程回退：把每个死锁进程备份到前面定义的某些检查点，并且重新启动所有进程－需要系统构造重新运行和重新启动机制</li>
</ul>
</blockquote>
<h4 id="死锁忽略"><a href="#死锁忽略" class="headerlink" title="死锁忽略"></a>死锁忽略</h4><p>通常实际中采用的方式…摆烂的成本最低。 </p>
<hr>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>终于写完这一部分了，是真的多，整整20课时的内容啊！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/veckun">Likun Wang (王立坤)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://your-domain.com/2023/02/13/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">https://your-domain.com/2023/02/13/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/">复习笔记</a><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">并发控制</a></div><div class="post-share"><div class="social-share" data-image="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e94870088ab1.png" data-sites="wechat,weibo,qq,twitter,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/02/14/en/UESTC-OS-Notes-3-Memory-Management/" title="UESTC Operating System Review Notes (3): Memory Management"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">UESTC Operating System Review Notes (3): Memory Management</div></div><div class="info-2"><div class="info-item-1">Table of Contents PrefaceMemory Management OverviewStorage System StructureProgram Birth ProcessAddress SpacesAddress MappingProgram Linking MethodsProgram Loading MethodsContiguous AllocationSingle Contiguous AllocationPartition ManagementFixed Partition AllocationDynamic Partition AllocationPartition Allocation AlgorithmsOverlay and SwappingDiscrete AllocationPaged Storage ManagementAddress TranslationPage TablesTwo-Level and Multi-Level Page TablesInverted Page TablesSegmented Storage Mana...</div></div></div></a><a class="pagination-related" href="/2023/02/13/en/UESTC-OS-Notes-2-Process-and-Concurrency-Control/" title="UESTC Operating System Review Notes (2): Process and Concurrency Control"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/e94870088ab1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">UESTC Operating System Review Notes (2): Process and Concurrency Control</div></div><div class="info-2"><div class="info-item-1">Table of Contents PrefaceProcess ManagementProcess BasicsPrecedence GraphsConcurrent ExecutionProcess Definition and CharacteristicsProcess StatesOperating System KernelProcess Control Block (PCB)Process CreationProcess Control Functions (fork and exec)Process TerminationProcess SwitchingThreadsProcessor SchedulingSingle Processor Scheduling (Key Topic)Scheduling AlgorithmsReal-Time SchedulingMulti-Processor SchedulingProcess Concurrency Control: Mutual Exclusion and SynchronizationSemaphores...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/02/15/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" title="电子科技大学操作系统期末复习笔记（四）：设备管理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/aa55f8cf800b.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-16</div><div class="info-item-2">电子科技大学操作系统期末复习笔记（四）：设备管理</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（四）：设备管理📊 1395 阅读 | 👍 8 点赞 | 💬 1 评论 | ⭐ 20 收藏  目录 前言 设备管理 I&#x2F;O系统 基本概念 设备使用特性 数据传输速率 数据传输单位 设备共享属性 设备控制器 I&#x2F;O通道 I&#x2F;O控制方式 程序I&#x2F;O控制方式 中断方式 直接存储器访问（DMA）  缓冲管理 单缓冲Single Buffer 双缓冲Double Buffer 循环缓冲Circular Buffer 缓冲池Buffer Pool I&#x2F;O软件 中断的工作方式 设备分配 设备分配算法 SPOOLing：假脱机操作 设备管理：调度与实例  磁盘存储器 基本概念 磁盘结构 地址转换 连接方式 DAS：磁盘挂载 NAS：网络挂载 SAN：存储区域网 磁盘访问 访问模式 访问时间 寻道时间 传输时间 (旋转)延迟时间 总访问时间 磁盘调度 先来先服务（FCFS） 最短寻道时间优先（SSTF） 扫描算法（SCAN, CSCAN） Look &amp; C-Look算法...</div></div></div></a><a class="pagination-related" href="/2023/02/18/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" title="电子科技大学操作系统期末复习笔记（五）：文件管理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://latex.csdn.net/eq?%5Cleftrightarrow" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-19</div><div class="info-item-2">电子科技大学操作系统期末复习笔记（五）：文件管理</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（五）：文件管理📊 2835 阅读 | 👍 16 点赞 | 💬 9 评论 | ⭐ 47 收藏  目录 前言 文件管理：基础 基本概念 文件 文件系统 文件系统的实现模型 文件的组成 文件名 文件分类 文件结构 逻辑结构 物理结构 练习题  文件管理：目录 文件控制块FCB FCB：File Control Block FCB信息 目录 基本概念 目录功能 目录基本操作 ⭐FCB组织方法 ⭐改进的FCB组织方法 目录的组织 路径 无环图目录 链接 通用图目录 文件管理：磁盘管理 空闲分区表 概念 特点  空闲分区链表 概念 特点 位示图 成组块链接法 分配方法 释放方法 例题 文件一致性：盘块 链接数一致性检查 文件执行 数据结构 文件共享 文件操作 执行过程 虚拟文件系统 VFS  前言设备管理模块已经更新，传送门：电子科技大学操作系统期末复习笔记（四）：设备管理 本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：   CM1： 操作系统概念。操作系统基本功...</div></div></div></a><a class="pagination-related" href="/2023/02/26/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/" title="电子科技大学软件工程期末复习笔记（四）：软件设计"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/77745a059f08.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-27</div><div class="info-item-2">电子科技大学软件工程期末复习笔记（四）：软件设计</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学软件工程期末复习笔记（四）：软件设计📊 2741 阅读 | 👍 13 点赞 | 💬 4 评论 | ⭐ 45 收藏  目录 前言 重点一览 软件工程设计 软件设计定义 软件设计包含的两类活动 软件设计包涵 软件的质量属性 各种设计技术 程序结构(深度、宽度、扇入、扇出) 完整的设计规格 软件体系架构 用户界面设计的3条原则 用户界面设计的3种分析 结构化设计方法 结构化程序设计的概念  流程图 程序流程图的主要缺点： 伪代码 NS图 PAD图 本章小结  前言本复习笔记基于王玉林老师的课堂PPT与复习大纲，供自己期末复习与学弟学妹参考用。  重点一览 分为两个部分讲解： 软件设计工程和结构化设计方法  软件工程设计软件设计定义软件设计定义为软件的架构、构件、接口和其他特性的定义过程及该过程的结果。  软件设计是：  软件工程生命周期中的一个活动 进行软件编码的基础 软件需求分析被转化为软件的内部结构 是连接用户需求和软件技术的桥梁   软件设计包含的两类活动 软件架构设计  又叫“概要设计”、“顶层设计” 描述软件的顶层架构和组织...</div></div></div></a><a class="pagination-related" href="/2023/02/11/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" title="电子科技大学操作系统期末复习笔记（一）：操作系统概述"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/5e52ba583b39.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-12</div><div class="info-item-2">电子科技大学操作系统期末复习笔记（一）：操作系统概述</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（一）：操作系统概述📊 2672 阅读 | 👍 23 点赞 | 💬 2 评论 | ⭐ 50 收藏  目录 前言 操作系统概述 操作系统的目标与功能 操作系统的定义 目标 功能 操作系统的历史 单用户系统 简单批处理系统 多道批处理系统 分时系统 个人电脑 → 分布式系统 → 互联网时代 → 移动计算时代 → …… 实时系统 操作系统的基本特征 并发 共享 虚拟 不确定性 操作系统的体系结构 无结构操作系统 模块化系统结构 分层式系统结构 操作系统安全 内存 信息保护和安全  前言本复习笔记基于电子科技大学计算机操作系统-教学大纲（2022）中的课程模块部分，分为五大章节，分别是：   CM1： 操作系统概念。操作系统基本功能、操作系统发展历史及趋势、操作系统主流架构、常见操作系统特点、操作系统安全机制。  CM2： 进程管理。进程概念、线程概念、进程生命周期、进程调度算法、进程同步互斥、进程间通信和死锁。  CM3： 内存管理。内存空间的概念、连续分配、离散分配（分页管理、分段管理、段页式管理）、虚拟存储管理...</div></div></div></a><a class="pagination-related" href="/2023/02/07/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98/" title="电子科技大学人工智能期末复习笔记（一）：搜索问题"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98/7efdc9ba252b.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-08</div><div class="info-item-2">电子科技大学人工智能期末复习笔记（一）：搜索问题</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学人工智能期末复习笔记（一）：搜索问题📊 9563 阅读 | 👍 56 点赞 | 💬 7 评论 | ⭐ 132 收藏  目录 前言 人工智能历史 搜索问题 什么是搜索问题？ 不知情搜索算法（Uninformed Search）  一些重要概念 深度优先搜索（DFS） 广度优先搜索（BFS）  代价敏感搜索（CCS）  代价一致搜索（UCS）  知情搜索算法（Informed Search）  启发式搜索（Heuristics Search）  贪心搜索（Greedy Search）  A*搜索 图搜索（Graph Search）  例题 实验：A*算法解决八数码问题 对抗搜索 零和游戏（Zero-sum Games） 极小化极大算法（Minimax Algorithm） Alpha-Beta剪枝算法（Alpha-Beta Pruning）  例题  前言本复习笔记基于李晶晶老师的课堂PPT与复习大纲，供自己期末复习与学弟学妹参考用。  人工智能历史 简要了解即可。   搜索问题什么是搜索问题？ 一个搜索问题包括一个状态空间，一个后...</div></div></div></a><a class="pagination-related" href="/2023/02/14/zh-CN/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/" title="电子科技大学操作系统期末复习笔记（三）：存储器管理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/%E7%94%B5%E5%AD%90%E7%A7%91%E6%8A%80%E5%A4%A7%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/0751d072f211.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-15</div><div class="info-item-2">电子科技大学操作系统期末复习笔记（三）：存储器管理</div></div><div class="info-2"><div class="info-item-1"> 本文迁移自CSDN博客原文链接：电子科技大学操作系统期末复习笔记（三）：存储器管理📊 3033 阅读 | 👍 14 点赞 | 💬 2 评论 | ⭐ 39 收藏  目录 前言 存储器管理 概述 存储管理 存储系统的结构 程序的诞生 空间分类 地址映射 程序链接的方式 静态链接 装入时动态链接 运行时动态链接 程序装入的方式 程序装入的两类三种方法 绝对装入 静态重定位 动态重定位√ 关键点 存储器管理：连续分配 单一连续分配 分区管理 固定分区分配 [放置算法（分配算法）] 动态分区分配 常用分区分配算法 [最先适配算法]  [循环最先适配算法]  [最佳适配算法]  [最坏适配算法] [伙伴系统] [碎片问题：紧凑&#x2F;动态重定位] 动态分区分配算法总结  覆盖 基本概念 实例 缺点 交换&#x2F;对换 基本概念 交换粒度  优缺点 交换与覆盖的比较 存储器管理：离散分配 页式存储管理 基本概念 [分页逻辑地址结构] [基本页式存储管理] [地址变换机构] 页式存储中的重定位 ⭐重点计算方法： 具有快表的地址变换机构 [快表] 计算页表存储空间 两级和多级页表 [...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comments</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Likun Wang (王立坤)</div><div class="author-info-description">Algorithm Engineer | AI Engineer
Waseda University M.E.
Deep Learning & TPU Development
</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">302</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">311</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/veckun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/veckun" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:vector_kun@ruri.waseda.jp" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://linkedin.com/in/veckun" target="_blank" title="LinkedIn"><i class="fab fa-linkedin" style="color: #0077b5;"></i></a><a class="social-icon" href="javascript:void(0)" target="_blank" title="WeChat vectorkun"><i class="fab fa-weixin" style="color: #07c160;"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_59180666" target="_blank" title="CSDN"><i class="fab fa-blogger" style="color: #fc5531;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcome to my blog! Sharing AI, algorithms & tech insights.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">进程基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.1.</span> <span class="toc-text">程序的顺序执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E8%B6%8B%E5%9B%BE"><span class="toc-number">2.1.2.</span> <span class="toc-text">前趋图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.3.</span> <span class="toc-text">程序的并发执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.4.</span> <span class="toc-text">并发程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.5.</span> <span class="toc-text">进程的定义和特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.6.</span> <span class="toc-text">进程的特征和状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8"><span class="toc-number">2.2.</span> <span class="toc-text">操作系统内核</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">2.2.2.</span> <span class="toc-text">功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD"><span class="toc-number">2.3.</span> <span class="toc-text">原语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">原子操作的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">操作系统控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB"><span class="toc-number">2.4.1.</span> <span class="toc-text">进程控制块PCB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E7%BB%87%EF%BC%88%E8%BF%9B%E7%A8%8B%E6%A0%91%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">进程组织（进程树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.4.3.</span> <span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%87%BD%E6%95%B0%EF%BC%88fork%E4%B8%8Eexec%E4%B8%BA%E4%B8%BB%EF%BC%89"><span class="toc-number">2.4.4.</span> <span class="toc-text">进程控制函数（fork与exec为主）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">2.4.5.</span> <span class="toc-text">进程的终止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">2.4.6.</span> <span class="toc-text">进程切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.5.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">2.5.1.</span> <span class="toc-text">与进程的区别和联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.5.2.</span> <span class="toc-text">线程的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.5.3.</span> <span class="toc-text">线程的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.5.4.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.5.5.</span> <span class="toc-text">线程的分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%E5%8D%95%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">⭐单处理机调度（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%8E%9F%E5%88%99"><span class="toc-number">3.1.1.</span> <span class="toc-text">调度原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">调度算法：资源分配问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%9AFCFS"><span class="toc-number">3.1.3.</span> <span class="toc-text">先来先服务：FCFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%9ASPF-SJF"><span class="toc-number">3.1.4.</span> <span class="toc-text">短作业优先：SPF&#x2F;SJF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%EF%BC%9ATSRR"><span class="toc-number">3.1.5.</span> <span class="toc-text">时间片轮转调度：TSRR</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%89%A9%E4%BD%99%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6%EF%BC%9ASRT"><span class="toc-number">3.1.6.</span> <span class="toc-text">最短剩余时间调度：SRT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%85%88%E6%9D%83-%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.7.</span> <span class="toc-text">基于优先权&#x2F;优先级的调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95%EF%BC%9AHRRN"><span class="toc-number">3.1.8.</span> <span class="toc-text">高响应比优先算法：HRRN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.9.</span> <span class="toc-text">多级队列调度算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%EF%BC%9AMFQ"><span class="toc-number">3.1.10.</span> <span class="toc-text">多级反馈队列调度：MFQ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.1.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6"><span class="toc-number">3.2.</span> <span class="toc-text">实时调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B%E4%B8%8B%E7%95%8C"><span class="toc-number">3.2.2.</span> <span class="toc-text">系统处理能力下界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.3.</span> <span class="toc-text">实时调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">3.3.</span> <span class="toc-text">多处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.3.2.</span> <span class="toc-text">进程分配方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%98%9F%E5%88%97%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">3.3.3.</span> <span class="toc-text">单队列多处理机调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%98%9F%E5%88%97%E5%A4%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">3.3.4.</span> <span class="toc-text">多队列多处理机调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E7%BB%84%E8%B0%83%E5%BA%A6"><span class="toc-number">3.3.5.</span> <span class="toc-text">成组调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%93%E7%94%A8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%86%E9%85%8D"><span class="toc-number">3.3.6.</span> <span class="toc-text">专用处理机分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="toc-number">4.</span> <span class="toc-text">进程并发控制：互斥与同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">进程&#x2F;线程的并发控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5"><span class="toc-number">4.3.</span> <span class="toc-text">同步的解决策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">软件方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">硬件方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">4.3.4.</span> <span class="toc-text">管程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%AD%90%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">⭐进程并发控制：信号量的应用（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">观察者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%B9%A6%E9%A6%86%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">图书馆问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E4%BA%A4%E8%BD%A6%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">公交车问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">⭐生产者&#x2F;消费者问题（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%9A"><span class="toc-number">5.4.1.</span> <span class="toc-text">例题：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%A4%BA"><span class="toc-number">5.4.2.</span> <span class="toc-text">启示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%E8%AF%BB-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">⭐读&#x2F;写者问题（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">5.5.1.</span> <span class="toc-text">读者优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E8%80%85%E4%BC%98%E5%85%88"><span class="toc-number">5.5.2.</span> <span class="toc-text">写者优先</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E4%BC%98%E5%85%88"><span class="toc-number">5.5.3.</span> <span class="toc-text">公平优先</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%E7%90%86%E5%8F%91%E5%B8%88%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">⭐理发师问题（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%AD%90%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">⭐哲学家问题（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="toc-number">5.8.</span> <span class="toc-text">重点知识点回顾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%9A%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">进程并发控制：练习题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%981"><span class="toc-number">6.1.</span> <span class="toc-text">问题1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%982"><span class="toc-number">6.2.</span> <span class="toc-text">问题2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%983"><span class="toc-number">6.3.</span> <span class="toc-text">问题3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%984"><span class="toc-number">6.4.</span> <span class="toc-text">问题4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%985"><span class="toc-number">6.5.</span> <span class="toc-text">问题5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%986"><span class="toc-number">6.6.</span> <span class="toc-text">问题6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%987"><span class="toc-number">6.7.</span> <span class="toc-text">问题7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%988"><span class="toc-number">6.8.</span> <span class="toc-text">问题8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%989"><span class="toc-number">6.9.</span> <span class="toc-text">问题9</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">7.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">7.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92"><span class="toc-number">7.2.</span> <span class="toc-text">消息传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88Pipe%EF%BC%89%E9%80%9A%E4%BF%A1"><span class="toc-number">7.3.</span> <span class="toc-text">管道（Pipe）通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.1.</span> <span class="toc-text">产生死锁的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">8.2.</span> <span class="toc-text">系统模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.3.</span> <span class="toc-text">资源类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE"><span class="toc-number">8.4.</span> <span class="toc-text">资源分配图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">8.4.1.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">8.4.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%85%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">8.5.</span> <span class="toc-text">死锁的充要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">8.6.</span> <span class="toc-text">处理死锁的基本方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="toc-number">8.6.1.</span> <span class="toc-text">死锁预防</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="toc-number">8.6.2.</span> <span class="toc-text">死锁避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B"><span class="toc-number">8.6.3.</span> <span class="toc-text">死锁检测</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E9%99%A4"><span class="toc-number">8.6.4.</span> <span class="toc-text">死锁解除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%BF%BD%E7%95%A5"><span class="toc-number">8.6.5.</span> <span class="toc-text">死锁忽略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-number">9.</span> <span class="toc-text">写在最后</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/04/en/Kiro-Batch-Registration-Vulnerability-Whistleblower/" title="On 'I Report Myself': The 'Modern-Day Hero' Behind Kiro's Batch Registration Vulnerability"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/kiro-whistleblower.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="On 'I Report Myself': The 'Modern-Day Hero' Behind Kiro's Batch Registration Vulnerability"/></a><div class="content"><a class="title" href="/2026/01/04/en/Kiro-Batch-Registration-Vulnerability-Whistleblower/" title="On 'I Report Myself': The 'Modern-Day Hero' Behind Kiro's Batch Registration Vulnerability">On 'I Report Myself': The 'Modern-Day Hero' Behind Kiro's Batch Registration Vulnerability</a><time datetime="2026-01-04T15:00:00.000Z" title="Created 2026-01-05 00:00:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/04/zh-CN/%E8%AE%BA%E3%80%8A%E6%88%91-%E4%B8%BE-%E6%8A%A5-%E6%88%91-%E8%87%AA-%E5%B7%B1%E3%80%8B%EF%BC%9AKiro-%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E6%BC%8F%E6%B4%9E%E8%83%8C%E5%90%8E%E7%9A%84%E2%80%9C%E5%BD%93%E4%BB%A3%E6%B4%BB%E9%9B%B7%E9%94%8B%E2%80%9D/" title="论《我 举 报 我 自 己》：Kiro 批量注册漏洞背后的&quot;当代活雷锋&quot;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/kiro-whistleblower.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论《我 举 报 我 自 己》：Kiro 批量注册漏洞背后的&quot;当代活雷锋&quot;"/></a><div class="content"><a class="title" href="/2026/01/04/zh-CN/%E8%AE%BA%E3%80%8A%E6%88%91-%E4%B8%BE-%E6%8A%A5-%E6%88%91-%E8%87%AA-%E5%B7%B1%E3%80%8B%EF%BC%9AKiro-%E6%89%B9%E9%87%8F%E6%B3%A8%E5%86%8C%E6%BC%8F%E6%B4%9E%E8%83%8C%E5%90%8E%E7%9A%84%E2%80%9C%E5%BD%93%E4%BB%A3%E6%B4%BB%E9%9B%B7%E9%94%8B%E2%80%9D/" title="论《我 举 报 我 自 己》：Kiro 批量注册漏洞背后的&quot;当代活雷锋&quot;">论《我 举 报 我 自 己》：Kiro 批量注册漏洞背后的&quot;当代活雷锋&quot;</a><time datetime="2026-01-04T15:00:00.000Z" title="Created 2026-01-05 00:00:00">2026-01-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/12/en/Common-Archive-Formats-Explained/" title="Common Archive Formats Explained: Differences and Extraction Methods"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Common Archive Formats Explained: Differences and Extraction Methods"/></a><div class="content"><a class="title" href="/2025/10/12/en/Common-Archive-Formats-Explained/" title="Common Archive Formats Explained: Differences and Extraction Methods">Common Archive Formats Explained: Differences and Extraction Methods</a><time datetime="2025-10-12T15:00:00.000Z" title="Created 2025-10-13 00:00:00">2025-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/12/zh-CN/%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E6%96%B9%E5%BC%8F/" title="常见压缩包格式详解：区别及在不同系统中的解压方式"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见压缩包格式详解：区别及在不同系统中的解压方式"/></a><div class="content"><a class="title" href="/2025/10/12/zh-CN/%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8E%8B%E6%96%B9%E5%BC%8F/" title="常见压缩包格式详解：区别及在不同系统中的解压方式">常见压缩包格式详解：区别及在不同系统中的解压方式</a><time datetime="2025-10-12T15:00:00.000Z" title="Created 2025-10-13 00:00:00">2025-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/09/18/en/Master-Python-Debugger-pdb-in-10-Minutes/" title="Master Python Debugger pdb in 10 Minutes"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/posts/10%E5%88%86%E9%92%9F%E6%8E%8C%E6%8F%A1Python%E8%B0%83%E8%AF%95%E5%99%A8pdb/0d565b653736.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Master Python Debugger pdb in 10 Minutes"/></a><div class="content"><a class="title" href="/2025/09/18/en/Master-Python-Debugger-pdb-in-10-Minutes/" title="Master Python Debugger pdb in 10 Minutes">Master Python Debugger pdb in 10 Minutes</a><time datetime="2025-09-18T15:00:00.000Z" title="Created 2025-09-19 00:00:00">2025-09-19</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By Likun Wang (王立坤)</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.3</a></span></div><div class="footer_custom_text"><p>Likun Wang | Algorithm Engineer</p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll to Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.3"></script><script src="/js/main.js?v=5.5.3"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.7/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'ams',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://your-twikoo.vercel.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://your-twikoo.vercel.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    GLOBAL_CONFIG_SITE.pageType === 'post' && getCount()

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo@1.6.44/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script src="/js/lang-router.js"></script><script src="/js/csdn-stats.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js" defer="defer"></script><script>document.addEventListener('DOMContentLoaded', () => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      true
        ? pjax.loadUrl('/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading Database</span></div><div class="local-search-input"><input placeholder="Search..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.3"></script></div></div></body></html>